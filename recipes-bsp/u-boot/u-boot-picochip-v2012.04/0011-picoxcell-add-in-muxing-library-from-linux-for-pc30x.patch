From 57c96d8fe6300fcc6b05770b11b0d6da222d5952 Mon Sep 17 00:00:00 2001
From: Dave Aldridge <david.aldridge@picochip.com>
Date: Tue, 10 May 2011 16:11:30 +0100
Subject: [PATCH 11/70] picoxcell: add in muxing library from linux for pc30xx devices

---
 arch/arm/cpu/arm926ejs/picoxcell/Makefile       |    1 +
 arch/arm/cpu/arm926ejs/picoxcell/axi2cfg.c      |  132 +++
 arch/arm/cpu/arm926ejs/picoxcell/gpio.c         |   39 +-
 arch/arm/cpu/arm926ejs/picoxcell/mux.c          | 1267 ++---------------------
 arch/arm/cpu/arm926ejs/picoxcell/utilities.c    |  145 +--
 arch/arm/include/asm/arch-picoxcell/mux.h       |  146 ++-
 arch/arm/include/asm/arch-picoxcell/utilities.h |   33 +-
 board/picochip/pc7302/nand.c                    |   52 +-
 board/picochip/pc7302/pc7302.c                  |  101 ++-
 board/picochip/pc7308/pc7308.c                  |   52 +-
 10 files changed, 575 insertions(+), 1393 deletions(-)
 create mode 100644 arch/arm/cpu/arm926ejs/picoxcell/axi2cfg.c

diff --git a/arch/arm/cpu/arm926ejs/picoxcell/Makefile b/arch/arm/cpu/arm926ejs/picoxcell/Makefile
index fbf27fd..2d8ca9f 100644
--- a/arch/arm/cpu/arm926ejs/picoxcell/Makefile
+++ b/arch/arm/cpu/arm926ejs/picoxcell/Makefile
@@ -51,6 +51,7 @@ COBJS-y += spi.o
 COBJS-y += utilities.o
 COBJS-y += mux.o
 COBJS-y += gpio.o
+COBJS-y += axi2cfg.o
 
 SRCS    := $(SOBJS-y:.o=.S) $(COBJS-y:.o=.c)
 OBJS    := $(addprefix $(obj),$(SOBJS-y) $(COBJS-y))
diff --git a/arch/arm/cpu/arm926ejs/picoxcell/axi2cfg.c b/arch/arm/cpu/arm926ejs/picoxcell/axi2cfg.c
new file mode 100644
index 0000000..7e4853c
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/picoxcell/axi2cfg.c
@@ -0,0 +1,132 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+ * \file axi2cfg.c
+ * \brief Various useful functions for the axi2cfg block.
+ *
+ * Copyright (c) 2006-2011 Picochip Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/* Includes ---------------------------------------------------------------- */
+#include <common.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+#include <asm/arch/picoxcell.h>
+#include <asm/arch/axi2cfg.h>
+#include <asm/arch/utilities.h>
+
+/* Macros ------------------------------------------------------------------ */
+/* Configuration port write bit positions. */
+#define CAEID_BIT_MASK     ( 1 << 19 )	/*!< Bit 19 - AE ID signal. */
+#define CADDR_BIT_MASK     ( 1 << 18 )	/*!< Bit 18 - AE ADDR signal. */
+#define CREAD_BIT_MASK     ( 1 << 17 )	/*!< Bit 17 - READ data signal. */
+#define CWRITE_BIT_MASK    ( 1 << 16 )	/*!< Bit 16 - WRITE data signal. */
+
+#define RB_FAIL_MASK       ( 1 << 17 )	/*!< Bit 17 - readback failed. */
+#define RB_VALID_MASK      ( 1 << 16 )	/*!< Bit 16 - readback valid. */
+
+#define RETRIES ( 10 )		/*!< The number of retries for an \
+				 *   AXI2Cfg config read. */
+
+/*! Register offset for the config bus write port (from the axi2cfg2 base
+ *  address). */
+#define AXI2CFG_REG_CFG_WR ( 0x0100 )
+
+/*! Register offset for the config bus read port (from the axi2cfg2 base
+ *  address). */
+#define AXI2CFG_REG_CFG_RD ( 0x0200 )
+
+/* Constants --------------------------------------------------------------- */
+
+/* Types ------------------------------------------------------------------- */
+
+/* Prototypes--------------------------------------------------------------- */
+
+/* Functions --------------------------------------------------------------- */
+unsigned long axi2cfg_readl(unsigned long offs)
+{
+        return readl(PICOXCELL_AXI2CFG_BASE + offs);
+}
+
+void axi2cfg_writel(unsigned long val, unsigned long offs)
+{
+        writel(val, (PICOXCELL_AXI2CFG_BASE + offs));
+}
+
+int axi2cfg_config_read (u16 caeid, u16 address, u16 * data, u16 count)
+{
+	u32 val;
+	unsigned int write_p = PICOXCELL_AXI2CFG_BASE + AXI2CFG_REG_CFG_WR;
+	unsigned int read_p = PICOXCELL_AXI2CFG_BASE + AXI2CFG_REG_CFG_RD;
+	u16 to_read = count;
+	u16 rc;
+	unsigned i;
+	unsigned retries;
+
+	val = caeid | CAEID_BIT_MASK;
+	picoxcell_write_register (val, write_p);
+
+	while (to_read) {
+		/* Output the address to read from. */
+		val = (address + (count - to_read)) | CADDR_BIT_MASK;
+		picoxcell_write_register (val, write_p);
+
+		/* Dispatch the read requests. */
+		rc = (to_read > 64) ? 64 : to_read;
+		val = CREAD_BIT_MASK | rc;
+		picoxcell_write_register (val, write_p);
+
+		/* Now read the values. */
+		for (i = 0; i < rc; ++i) {
+			retries = RETRIES;
+			while (retries) {
+				val = picoxcell_read_register (read_p);
+				if (val & (RB_VALID_MASK | RB_FAIL_MASK))
+					break;
+				--retries;
+			}
+
+			if (!retries || (val & RB_FAIL_MASK)) {
+				break;
+			} else
+				data[(count - to_read) + i] = val & 0xFFFF;
+		}
+
+		if (val & RB_FAIL_MASK)
+			break;
+
+		to_read -= rc;
+	}
+
+	return !(val & RB_FAIL_MASK) ? count : -EIO;
+}
+
+int axi2cfg_config_write (u16 caeid, u16 address, u16 * data, u16 count)
+{
+	u32 val;
+	unsigned int write_p = PICOXCELL_AXI2CFG_BASE + AXI2CFG_REG_CFG_WR;
+	unsigned i;
+
+	val = caeid | CAEID_BIT_MASK;
+	picoxcell_write_register (val, write_p);
+
+	/* Output the address to write to */
+	val = address | CADDR_BIT_MASK;
+	picoxcell_write_register (val, write_p);
+
+	/* Now write the values. */
+	for (i = 0; i < count; ++i) {
+		val = data[i] | CWRITE_BIT_MASK;
+		picoxcell_write_register (val, write_p);
+	}
+
+	return i;
+}
diff --git a/arch/arm/cpu/arm926ejs/picoxcell/gpio.c b/arch/arm/cpu/arm926ejs/picoxcell/gpio.c
index e4817f6..e4bf981 100644
--- a/arch/arm/cpu/arm926ejs/picoxcell/gpio.c
+++ b/arch/arm/cpu/arm926ejs/picoxcell/gpio.c
@@ -99,22 +99,9 @@ static struct gpio_desc gpio_desc[ARCH_NR_GPIOS];
 /* Functions --------------------------------------------------------------- */
 static int armgpio_request (struct gpio_chip *chip, unsigned offset)
 {
-	enum mux_setting mux;
-
 	if (test_and_set_bit (offset + chip->base, pin_status))
 		return -EBUSY;
 
-	/* Check the pin has been correctly multiplexed. */
-	mux = picoxcell_get_pin_mux (offset + chip->base);
-	if (!(mux & (MUX_ARM | MUX_UNMUXED))) {
-		/* The pin has an inconsistent mux setting. */
-		printf
-		    ("attempt to request armgpio%u which is not correctly multiplexed\n",
-		     chip->base + offset);
-		test_and_clear_bit (offset + chip->base, pin_status);
-		return -EIO;
-	}
-
 	return 0;
 }
 
@@ -129,7 +116,7 @@ static void armgpio_free (struct gpio_chip *chip, unsigned offset)
 
 static inline int armgpio_block_nr (unsigned gpio_nr)
 {
-	if (!is_pc3x3 ()) {
+	if (picoxcell_is_pc3x2 ()) {
 		/*
 		 * PC3X2 has GPIOs numbered in non contiguous blocks.
 		 */
@@ -170,7 +157,7 @@ static inline int armgpio_block_nr (unsigned gpio_nr)
 
 static inline unsigned armgpio_offset (unsigned offset)
 {
-	if (is_pc3x3 ()) {
+	if (picoxcell_is_pc3x3 ()) {
 		/*
 		 * The arm gpios in PC3x3 are controlled via three sets of
 		 * registers. The register addressing is already taken care
@@ -476,7 +463,7 @@ static int sdgpio_reset_config (unsigned block_pin, int value)
 
 static inline int sdgpio_block_nr (unsigned gpio_nr)
 {
-	if (is_pc3x3 ()) {
+	if (picoxcell_is_pc3x3 ()) {
 		return gpio_nr - PC3X3_GPIO_PIN_SDGPIO_0;
 	} else {
 		if (gpio_nr >= PC302_GPIO_PIN_SDGPIO_0 &&
@@ -490,7 +477,6 @@ static inline int sdgpio_block_nr (unsigned gpio_nr)
 static int sdgpio_request (struct gpio_chip *chip, unsigned offset)
 {
 	unsigned block_pin = sdgpio_block_nr (chip->base + offset);
-	enum mux_setting mux;
 
 	if (test_and_set_bit (offset + chip->base, pin_status))
 		return -EBUSY;
@@ -500,17 +486,6 @@ static int sdgpio_request (struct gpio_chip *chip, unsigned offset)
 		return -EIO;
 	}
 
-	/* Check the pin has been correctly multiplexed. */
-	mux = picoxcell_get_pin_mux (offset + chip->base);
-	if (!(mux & (MUX_SD | MUX_UNMUXED))) {
-		/* The pin has an inconsistent mux setting. */
-		printf
-		    ("attempt to request sdgpio%u which is not correctly multiplexed\n",
-		     block_pin);
-		test_and_clear_bit (offset + chip->base, pin_status);
-		return -EIO;
-	}
-
 	return 0;
 }
 
@@ -536,7 +511,7 @@ static int sdgpio_get_digital_out_status (u32 * v)
 				      &data[0], 1))
 		return -EIO;
 
-	if (is_pc3x3 ()) {
+	if (picoxcell_is_pc3x3 ()) {
 		if (1 != axi2cfg_config_read (PICOXCELL_AXI2PICO_CAEID,
 					      PICOXCELL_GPIO_SD_OUTPUT_HI_VAL_REG,
 					      &data[1], 1))
@@ -557,7 +532,7 @@ static int sdgpio_set_digital_out_status (u32 v)
 				       &data[0], 1))
 		return -EIO;
 
-	if (is_pc3x3 ()) {
+	if (picoxcell_is_pc3x3 ()) {
 		if (1 != axi2cfg_config_write (PICOXCELL_AXI2PICO_CAEID,
 					       PICOXCELL_GPIO_SD_OUTPUT_HI_VAL_REG,
 					       &data[1], 1))
@@ -614,7 +589,7 @@ static int sdgpio_get_digital_in_status (u32 * v)
 				      1))
 		return -EIO;
 
-	if (is_pc3x3 ()) {
+	if (picoxcell_is_pc3x3 ()) {
 		if (1 != axi2cfg_config_read (PICOXCELL_AXI2PICO_CAEID,
 					      PICOXCELL_GPIO_SD_INPUT_VAL_HI_REG,
 					      &data[1], 1))
@@ -932,7 +907,7 @@ int picoxcell_gpio_init (void)
 		return -EIO;
 	}
 
-	if (is_pc3x3 ()) {
+	if (picoxcell_is_pc3x3 ()) {
 		num_chips = ARRAY_SIZE (pc3x3_chips);
 		all_chips = pc3x3_chips;
 	} else {
diff --git a/arch/arm/cpu/arm926ejs/picoxcell/mux.c b/arch/arm/cpu/arm926ejs/picoxcell/mux.c
index 990420b..fe249f7 100644
--- a/arch/arm/cpu/arm926ejs/picoxcell/mux.c
+++ b/arch/arm/cpu/arm926ejs/picoxcell/mux.c
@@ -2,11 +2,8 @@
  * $picoChipHeaderSubst$
  *****************************************************************************/
 
-/*!
- * \file mux.c
- * \brief Muxing control for the gpio pins.
- *
- * Copyright (c) 2009-2011 Picochip Ltd.
+/*
+ * Copyright (c) 2010-2011 Picochip Ltd., Jamie Iles
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -15,1240 +12,120 @@
  * All enquiries to support@picochip.com
  */
 
-/* Includes ---------------------------------------------------------------- */
-#include <common.h>
-#include <asm/errno.h>
-#include <asm/arch/picoxcell.h>
-#include <asm/arch/utilities.h>
-#include <asm/arch/axi2cfg.h>
-#include <asm/arch/mux.h>
-#include <asm/arch/picoxcell_gpio.h>
-
-/* Constants --------------------------------------------------------------- */
-/*
- * A multiplexed pin. This defines the SD and ARM pins that are on the pad. If
- * the pin does not have an SD or ARM pin then set the appropriate field to
- * -1.
- */
-struct muxed_pin {
-	const char *name;
-	int is_dedicated_gpio;
-	int sd_pin;
-	int arm_pin;
-	int (*set_mux) (struct muxed_pin * pin, enum mux_setting setting);
-	int (*get_mux) (struct muxed_pin * pin);
-};
-
-/*
- * A logical group of multiplexed pins. Typically this is grouped by what the
- * pins are multiplexed with e.g. system peripheral.
- */
-struct pin_group {
-	int nr_pins;
-	const char *name;
-	struct muxed_pin *pins;
-};
+#include <linux/bitops.h>
+#include <errno.h>
+#include <asm/io.h>
+#include <linux/string.h>
 
-/* Macros ------------------------------------------------------------------ */
-#define __PIN(_name, _sd, _arm, _set, _get)		        \
-	.name		    = __stringify(_name),		\
-	.is_dedicated_gpio  = 0,				\
-	.sd_pin		    = (_sd),				\
-	.arm_pin    	    = (_arm),				\
-	.set_mux    	    = _set,				\
-	.get_mux    	    = _get
-/*
- * Declare a function pin that is also multiplexed with GPIO pins.
- */
-#define PIN(_name, _sd, _arm, _set, _get) {			\
-	__PIN(_name, _sd, _arm, _set, _get),			\
-	.is_dedicated_gpio  = 0,				\
-}
+#include <asm/arch/mux.h>
+#include <asm/arch/utilities.h>
 
-/*
- * Declare a pure GPIO pin.
- */
-#define GPIO(_name, _sd, _arm, _set, _get) {			\
-	__PIN(_name, _sd, _arm, _set, _get),			\
-	.is_dedicated_gpio  = 1,				\
-}
+static LIST_HEAD(mux_defs);
 
-/* Functions --------------------------------------------------------------- */
-/*****************************************************************************
- * PC302 pin multiplexing.
- ****************************************************************************/
-#ifdef CONFIG_PICOCHIP_PC3X2
-
-static int pai_get_mux (struct muxed_pin *pin)
+void picoxcell_mux_register(struct mux_def *defs, int nr_defs)
 {
-#define PAI_GPIO_PIN_ARM_4	0xB
-#define PAI_GPIO_PIN_ARM_5	0xA
-#define PAI_GPIO_PIN_ARM_6	0x9
-#define PAI_GPIO_PIN_ARM_7	0x8
-#define PAI_GPIO_PIN_SDGPIO_4	0x7
-#define PAI_GPIO_PIN_SDGPIO_5	0x6
-#define PAI_GPIO_PIN_SDGPIO_6	0x5
-#define PAI_GPIO_PIN_SDGPIO_7	0x4
-#define PICOXCELL_PAI_CAEID	0x8080
-#define PAI_SLEEP_REG		0xA060
-#define PAI_IO_CTRL_REG		0x0009
-
-	/* Make sure that the PAI block is awake. */
-	u16 data = 0, sd_mask = 0, arm_mask = 0;
-	int ret = axi2cfg_config_write (PICOXCELL_PAI_CAEID, PAI_SLEEP_REG,
-					&data, 1);
-	if (1 != ret) {
-		printf ("unable to wake up PAI\n");
-		return -EIO;
-	}
-
-	/* Get the current PAI muxing configuration. */
-	ret =
-	    axi2cfg_config_read (PICOXCELL_PAI_CAEID, PAI_IO_CTRL_REG, &data,
-				 1);
-	if (1 != ret) {
-		printf ("unable to read PAI I/O control reg\n");
-		return -EIO;
-	}
-
-	if (pin->sd_pin == PC302_GPIO_PIN_SDGPIO_4) {
-		sd_mask |= PAI_GPIO_PIN_SDGPIO_4;
-	} else if (pin->sd_pin == PC302_GPIO_PIN_SDGPIO_5) {
-		sd_mask |= PAI_GPIO_PIN_SDGPIO_5;
-	} else if (pin->sd_pin == PC302_GPIO_PIN_SDGPIO_6) {
-		sd_mask |= PAI_GPIO_PIN_SDGPIO_6;
-	} else if (pin->sd_pin == PC302_GPIO_PIN_SDGPIO_7) {
-		sd_mask |= PAI_GPIO_PIN_SDGPIO_7;
-	} else if (pin->arm_pin == PC302_GPIO_PIN_ARM_4) {
-		arm_mask |= PAI_GPIO_PIN_ARM_4;
-	} else if (pin->arm_pin == PC302_GPIO_PIN_ARM_5) {
-		arm_mask |= PAI_GPIO_PIN_ARM_5;
-	} else if (pin->arm_pin == PC302_GPIO_PIN_ARM_6) {
-		arm_mask |= PAI_GPIO_PIN_ARM_6;
-	} else if (pin->arm_pin == PC302_GPIO_PIN_ARM_7) {
-		arm_mask |= PAI_GPIO_PIN_ARM_7;
-	} else {
-		ret = -EINVAL;
-		goto out;
-	}
+	int i;
 
-	if (data & sd_mask)
-		ret = MUX_SD;
-	else if (data & arm_mask)
-		ret = MUX_ARM;
-	else
-		ret = MUX_PERIPHERAL;
-
-out:
-	return ret;
+	for (i = 0; i < nr_defs; ++i)
+		list_add_tail(&defs[i].head, &mux_defs);
 }
 
-static int pai_set_mux (struct muxed_pin *pin, enum mux_setting setting)
+static int mux_set_config_bus(struct mux_def *def, enum mux_setting setting)
 {
-	/* Make sure that the PAI block is awake. */
 	u16 data = 0;
-	int err = axi2cfg_config_write (PICOXCELL_PAI_CAEID, PAI_SLEEP_REG,
-					&data, 1);
-	if (1 != err) {
-		printf ("unable to wake up PAI\n");
-		return -EIO;
-	}
-
-	/* Get the current PAI muxing configuration. */
-	err =
-	    axi2cfg_config_read (PICOXCELL_PAI_CAEID, PAI_IO_CTRL_REG, &data,
-				 1);
-	if (1 != err) {
-		printf ("unable to read PAI I/O control reg\n");
-		return -EIO;
-	}
-
-	if (MUX_SD == setting) {
-		if (pin->sd_pin == PC302_GPIO_PIN_SDGPIO_4) {
-			data |= PAI_GPIO_PIN_SDGPIO_4;
-		} else if (pin->sd_pin == PC302_GPIO_PIN_SDGPIO_5) {
-			data |= PAI_GPIO_PIN_SDGPIO_5;
-		} else if (pin->sd_pin == PC302_GPIO_PIN_SDGPIO_6) {
-			data |= PAI_GPIO_PIN_SDGPIO_6;
-		} else if (pin->sd_pin == PC302_GPIO_PIN_SDGPIO_7) {
-			data |= PAI_GPIO_PIN_SDGPIO_7;
-		} else {
-			err = -EINVAL;
-			goto out;
-		}
-	} else if (MUX_ARM == setting) {
-		if (pin->arm_pin == PC302_GPIO_PIN_ARM_4) {
-			data |= PAI_GPIO_PIN_ARM_4;
-		} else if (pin->arm_pin == PC302_GPIO_PIN_ARM_5) {
-			data |= PAI_GPIO_PIN_ARM_5;
-		} else if (pin->arm_pin == PC302_GPIO_PIN_ARM_6) {
-			data |= PAI_GPIO_PIN_ARM_6;
-		} else if (pin->arm_pin == PC302_GPIO_PIN_ARM_7) {
-			data |= PAI_GPIO_PIN_ARM_7;
-		} else {
-			err = -EINVAL;
-			goto out;
-		}
-	} else if (MUX_PERIPHERAL == setting) {
-		/*
-		 * We don't do anything here. The PAI is only driven by the
-		 * picoArray so this will be automatically set in the loadfile
-		 * when the design is next loaded.
-		 */
-		err = 0;
-	} else if (MUX_UNMUXED == setting) {
-		/* This can't be changed at run-time! */
-		return -EPERM;
-	}
-
-	err =
-	    axi2cfg_config_write (PICOXCELL_PAI_CAEID, PAI_IO_CTRL_REG, &data,
-				  1);
-	if (1 != err) {
-		printf ("unable to write PAI I/O control reg\n");
-		return -EIO;
-	}
-
-	err = 0;
-
-out:
-	return err;
-}
-
-static struct muxed_pin pai_pins[] = {
-	PIN (sdgpio4, PC302_GPIO_PIN_SDGPIO_4, -1, pai_set_mux,
-	     pai_get_mux),
-	PIN (sdgpio5, PC302_GPIO_PIN_SDGPIO_5, -1, pai_set_mux,
-	     pai_get_mux),
-	PIN (sdgpio6, PC302_GPIO_PIN_SDGPIO_6, -1, pai_set_mux,
-	     pai_get_mux),
-	PIN (sdgpio7, PC302_GPIO_PIN_SDGPIO_7, -1, pai_set_mux,
-	     pai_get_mux),
-	PIN (arm4, -1, PC302_GPIO_PIN_ARM_4, pai_set_mux, pai_get_mux),
-	PIN (arm5, -1, PC302_GPIO_PIN_ARM_5, pai_set_mux, pai_get_mux),
-	PIN (arm6, -1, PC302_GPIO_PIN_ARM_6, pai_set_mux, pai_get_mux),
-	PIN (arm7, -1, PC302_GPIO_PIN_ARM_7, pai_set_mux, pai_get_mux),
-};
-
-static struct pin_group pai_group = {
-	.nr_pins = ARRAY_SIZE (pai_pins),
-	.name = "pai/ebi",
-	.pins = pai_pins,
-};
-
-static int shd_get_mux (struct muxed_pin *pin)
-{
-	unsigned bit;
-	unsigned long syscfg = syscfg_read ();
-
-	if (0 == (syscfg & 0x3) && pin->sd_pin == PC302_GPIO_PIN_SDGPIO_15)
-		return MUX_PERIPHERAL;
-
-	if (pin->sd_pin == PC302_GPIO_PIN_SDGPIO_0) {
-		if (syscfg & AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK)
-			return MUX_PERIPHERAL;
-		else
-			return MUX_SD;
-	}
 
-	bit = 1 << (AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_SEL_LO +
-		    pin->sd_pin - PC302_GPIO_PIN_SDGPIO_8);
-
-	return syscfg & bit ? MUX_ARM : MUX_SD;
-}
+	if (setting != MUX_ARM && setting != MUX_SD)
+		return -EINVAL;
 
-static int shd_set_mux (struct muxed_pin *pin, enum mux_setting setting)
-{
-	unsigned bit;
-	unsigned long syscfg = syscfg_read ();
+	if ((setting == MUX_ARM && def->armgpio < 0) ||
+	    (setting == MUX_SD && def->sdgpio < 0))
+		return -EINVAL;
 
-	/*
-	 * In parallel boot mode, shared pin 7 can't be used as it is always
-	 * on the EBI.
-	 */
-	if (0 == (syscfg & 0x3) && pin->sd_pin == PC302_GPIO_PIN_SDGPIO_15)
-		return -EBUSY;
+	/* Wake the AE up. */
+	axi2cfg_config_write(def->caeid, 0xA060, &data, 1);
 
-	switch (setting) {
-	case MUX_PERIPHERAL:
-		/*
-		 * SDGPIO pin 0 is shared with the Frac-N.
-		 */
-		if (PC302_GPIO_PIN_SDGPIO_0 == pin->sd_pin) {
-			syscfg_update (AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK,
-				       AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK);
-			break;
-		}
+	/* Set the new muxing mask. */
+	if (axi2cfg_config_read(def->caeid, def->caddr, &data, 1) != 1)
 		return -EIO;
-
-	case MUX_SD:
-		syscfg_update (AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK, 0);
-		bit = 1 << (AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_SEL_LO +
-			    pin->sd_pin - PC302_GPIO_PIN_SDGPIO_8);
-		syscfg_update (bit, 0);
-		break;
-
-	case MUX_ARM:
-		if (PC302_GPIO_PIN_SDGPIO_0 == pin->sd_pin)
-			return -EINVAL;
-		syscfg_update (AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK, 0);
-		bit = 1 << (AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_SEL_LO +
-			    pin->arm_pin - PC302_GPIO_PIN_ARM_8);
-		syscfg_update (bit, bit);
-		break;
-
-	case MUX_UNMUXED:
-		/* This can't be changed at run-time! */
-		return -EPERM;
-	}
+	data |= def->mask;
+	axi2cfg_config_write(def->caeid, def->caddr, &data, 1);
 
 	return 0;
 }
 
-static struct muxed_pin shared_pins[] = {
-	GPIO (shared0, PC302_GPIO_PIN_SDGPIO_8, PC302_GPIO_PIN_ARM_8,
-	      shd_set_mux,
-	      shd_get_mux),
-	GPIO (shared1, PC302_GPIO_PIN_SDGPIO_9, PC302_GPIO_PIN_ARM_9,
-	      shd_set_mux,
-	      shd_get_mux),
-	GPIO (shared2, PC302_GPIO_PIN_SDGPIO_10, PC302_GPIO_PIN_ARM_10,
-	      shd_set_mux,
-	      shd_get_mux),
-	GPIO (shared3, PC302_GPIO_PIN_SDGPIO_11, PC302_GPIO_PIN_ARM_11,
-	      shd_set_mux,
-	      shd_get_mux),
-	GPIO (shared4, PC302_GPIO_PIN_SDGPIO_12, PC302_GPIO_PIN_ARM_12,
-	      shd_set_mux,
-	      shd_get_mux),
-	GPIO (shared5, PC302_GPIO_PIN_SDGPIO_13, PC302_GPIO_PIN_ARM_13,
-	      shd_set_mux,
-	      shd_get_mux),
-	GPIO (shared6, PC302_GPIO_PIN_SDGPIO_14, PC302_GPIO_PIN_ARM_14,
-	      shd_set_mux,
-	      shd_get_mux),
-	PIN (shared7, PC302_GPIO_PIN_SDGPIO_15, PC302_GPIO_PIN_ARM_15,
-	     shd_set_mux,
-	     shd_get_mux),
-};
-
-static struct pin_group shd_group = {
-	.nr_pins = ARRAY_SIZE (shared_pins),
-	.name = "shared/ebi",
-	.pins = shared_pins,
-};
-
-static struct muxed_pin fracn_pins[] = {
-	PIN (sdgpio0, PC302_GPIO_PIN_SDGPIO_0, -1, shd_set_mux,
-	     shd_get_mux),
-};
-
-static struct pin_group fracn_group = {
-	.nr_pins = ARRAY_SIZE (fracn_pins),
-	.name = "fracn/sdgpio0",
-	.pins = fracn_pins,
-};
-
-static struct pin_group *pc3x2_groups[] = {
-	&shd_group,
-	&pai_group,
-	&fracn_group,
-};
-#endif /* CONFIG_PICOCHIP_PC3X2 */
-
-/*****************************************************************************
- * PC3X3 pin multiplexing.
- ****************************************************************************/
-#ifdef CONFIG_PICOCHIP_PC3X3
-
-#define SHD_GPIO_MUX_REG        (PICOXCELL_AXI2CFG_BASE + \
-				 AXI2CFG_SHD_GPIO_MUXING_REG_OFFSET)
-#define USE_EBI_GPIO_REG	(PICOXCELL_AXI2CFG_BASE + \
-				 AXI2CFG_USE_EBI_GPIO_REG_OFFSET)
-#define USE_PAI_GPIO_REG	(PICOXCELL_AXI2CFG_BASE + \
-				 AXI2CFG_USE_PAI_GPIO_REG_OFFSET)
-#define USE_DECODE_GPIO_REG	(PICOXCELL_AXI2CFG_BASE + \
-				 AXI2CFG_USE_DECODE_GPIO_REG_OFFSET)
-#define USE_MISC_INT_GPIO_REG	(PICOXCELL_AXI2CFG_BASE + \
-				 AXI2CFG_USE_MISC_INT_GPIO_REG_OFFSET)
-
-/*
- * Set the muxing of one of the shared pins.
- */
-static void pc3xx_shd_gpio_set_mux (int arm_pin_nr, enum mux_setting setting)
-{
-	unsigned long shd_mux = picoxcell_read_register (SHD_GPIO_MUX_REG);
-
-	if (MUX_ARM == setting)
-		shd_mux |= (1 << arm_pin_nr);
-	else
-		shd_mux &= ~(1 << arm_pin_nr);
-
-	picoxcell_write_register (shd_mux, SHD_GPIO_MUX_REG);
-}
-
-static int pc3xx_get_shd_mux (struct muxed_pin *pin)
+static int mux_configure(struct mux_def *def, enum mux_setting setting)
 {
-	unsigned long shd_mux = picoxcell_read_register (SHD_GPIO_MUX_REG);
-	unsigned long syscfg = syscfg_read ();
+	unsigned long periph_ctrl;
 
-	if (pin->sd_pin == PC3X3_GPIO_PIN_SDGPIO_0) {
-		if (syscfg & AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK)
-			return MUX_PERIPHERAL;
-		else
-			return MUX_SD;
-	}
-
-	return shd_mux & (1 << pin->arm_pin) ? MUX_ARM : MUX_SD;
-}
-
-/*
- * Shared ARM/SD gpio pins. These pins go to the arm_gpio[3:0] pads but can
- * be arm or sdgpio.
- */
-static int pc3xx_shd_mux (struct muxed_pin *pin, enum mux_setting setting)
-{
-	if (MUX_PERIPHERAL == setting) {
-		if (pin->sd_pin != PC3X3_GPIO_PIN_SDGPIO_0)
-			return -EINVAL;
+	if (def->flags & MUX_RO)
+		return -EPERM;
 
-		syscfg_update (AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK,
-			       AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK);
-	} else if (PC3X3_GPIO_PIN_SDGPIO_0 == pin->sd_pin) {
-		syscfg_update (AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK, 0);
-	}
+	if (def->flags & MUX_CONFIG_BUS)
+		return mux_set_config_bus(def, setting);
 
-	if (PC3X3_GPIO_PIN_SDGPIO_0 == pin->sd_pin && MUX_ARM == setting)
+	if (!((def->armgpio >= 0 && setting == MUX_ARM) ||
+	      (def->sdgpio >= 0 && setting == MUX_SD) ||
+	      (def->periph >= 0 && setting == def->periph)))
 		return -EINVAL;
 
-	pc3xx_shd_gpio_set_mux (pin->arm_pin, setting);
-
-	return 0;
-}
-
-static struct muxed_pin armgpio_0_4[] = {
-	GPIO (arm_gpio0, PC3X3_GPIO_PIN_SDGPIO_16, PC3X3_GPIO_PIN_ARM_0,
-	      pc3xx_shd_mux,
-	      pc3xx_get_shd_mux),
-	GPIO (arm_gpio1, PC3X3_GPIO_PIN_SDGPIO_17, PC3X3_GPIO_PIN_ARM_1,
-	      pc3xx_shd_mux,
-	      pc3xx_get_shd_mux),
-	GPIO (arm_gpio2, PC3X3_GPIO_PIN_SDGPIO_18, PC3X3_GPIO_PIN_ARM_2,
-	      pc3xx_shd_mux,
-	      pc3xx_get_shd_mux),
-	GPIO (arm_gpio3, PC3X3_GPIO_PIN_SDGPIO_19, PC3X3_GPIO_PIN_ARM_3,
-	      pc3xx_shd_mux,
-	      pc3xx_get_shd_mux),
-};
-
-static struct pin_group armgpio_0_4_group = {
-	.nr_pins = ARRAY_SIZE (armgpio_0_4),
-	.name = "arm_gpio[3:0]",
-	.pins = armgpio_0_4,
-};
-
-static struct muxed_pin shd_gpio[] = {
-	GPIO (shd_gpio, PC3X3_GPIO_PIN_SDGPIO_8, PC3X3_GPIO_PIN_ARM_8,
-	      pc3xx_shd_mux,
-	      pc3xx_get_shd_mux),
-};
-
-static struct pin_group pc3x3_shd_group = {
-	.nr_pins = ARRAY_SIZE (shd_gpio),
-	.name = "shd_gpio",
-	.pins = shd_gpio,
-};
-
-/*
- * boot_mode[1:0] pads - the pins switch to gpio automatically after boot and
- * can be either arm or sdgpio.
- */
-static struct muxed_pin boot_mode_0_1[] = {
-	GPIO (boot_mode0, PC3X3_GPIO_PIN_SDGPIO_9, PC3X3_GPIO_PIN_ARM_9,
-	      pc3xx_shd_mux, pc3xx_get_shd_mux),
-	GPIO (boot_mode1, PC3X3_GPIO_PIN_SDGPIO_10, PC3X3_GPIO_PIN_ARM_10,
-	      pc3xx_shd_mux, pc3xx_get_shd_mux),
-};
-
-static struct pin_group boot_mode_group = {
-	.nr_pins = ARRAY_SIZE (boot_mode_0_1),
-	.name = "boot_mode[1:0]",
-	.pins = boot_mode_0_1,
-};
-
-/*
- * sdram_speed_sel pad - automatically switches to gpio after boot and can be
- * arm or sdgpio.
- */
-static struct muxed_pin sdram_speed_sel[] = {
-	GPIO (sdram_speed_sel, PC3X3_GPIO_PIN_SDGPIO_11, PC3X3_GPIO_PIN_ARM_11,
-	      pc3xx_shd_mux, pc3xx_get_shd_mux),
-};
-
-static struct pin_group sdram_speed_sel_group = {
-	.nr_pins = ARRAY_SIZE (sdram_speed_sel),
-	.name = "sdram_speed_sel",
-	.pins = sdram_speed_sel,
-};
-
-/*
- * mii_rev_en pad - automatically switches to gpio after boot and can be
- * arm or sdgpio.
- */
-static struct muxed_pin mii_rev_en[] = {
-	GPIO (mii_rev_en, PC3X3_GPIO_PIN_SDGPIO_12, PC3X3_GPIO_PIN_ARM_12,
-	      pc3xx_shd_mux, pc3xx_get_shd_mux),
-};
-
-static struct pin_group mii_rev_en_group = {
-	.nr_pins = ARRAY_SIZE (mii_rev_en),
-	.name = "mii_rev_en",
-	.pins = mii_rev_en,
-};
-
-/*
- * mii_rmii_en pad - automatically switches to gpio after boot and can be
- * arm or sdgpio.
- */
-static struct muxed_pin mii_rmii_en[] = {
-	GPIO (mii_rmii_en, PC3X3_GPIO_PIN_SDGPIO_13, PC3X3_GPIO_PIN_ARM_13,
-	      pc3xx_shd_mux, pc3xx_get_shd_mux),
-};
-
-static struct pin_group mii_rmii_en_group = {
-	.nr_pins = ARRAY_SIZE (mii_rmii_en),
-	.name = "mii_rmii_en",
-	.pins = mii_rmii_en,
-};
-
-/*
- * mii_speed_sel pad - automatically switches to gpio after boot and can be
- * arm or sdgpio.
- */
-static struct muxed_pin mii_speed_sel[] = {
-	GPIO (mii_speed_sel, PC3X3_GPIO_PIN_SDGPIO_14, PC3X3_GPIO_PIN_ARM_14,
-	      pc3xx_shd_mux, pc3xx_get_shd_mux),
-};
-
-static struct pin_group mii_speed_sel_group = {
-	.nr_pins = ARRAY_SIZE (mii_speed_sel),
-	.name = "mii_speed_sel",
-	.pins = mii_speed_sel,
-};
-
-static int pc3x3_shd_ebi_get_mux (struct muxed_pin *pin)
-{
-	int ebi_pin, err = 0, can_be_sd = 1;
-	unsigned long ebi_mux;
-
-	ebi_mux = picoxcell_read_register (USE_EBI_GPIO_REG);
-
-	/*
-	 * Find out what EBI pin our GPIO maps to.
-	 */
-	if (pin->arm_pin >= PC3X3_GPIO_PIN_ARM_4 &&
-	    pin->arm_pin < PC3X3_GPIO_PIN_ARM_8) {
-		ebi_pin = 22 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_4);
-	} else if (pin->arm_pin >= PC3X3_GPIO_PIN_ARM_20 &&
-		   pin->arm_pin < PC3X3_GPIO_PIN_ARM_24) {
-		ebi_pin = 18 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_20);
-	} else {
-		/* These aren't shared gpio pins. */
-		ebi_pin = 14 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_14);
-		can_be_sd = 0;
-	}
-
-	if (!(ebi_mux & (1 << (ebi_pin - 14)))) {
-		err = MUX_PERIPHERAL;
-		goto out;
-	}
-
-	if (can_be_sd)
-		err = pc3xx_get_shd_mux (pin);
-	else
-		err = MUX_ARM;
-
-out:
-	return err;
-}
-
-static int
-pc3x3_shd_ebi_set_mux (struct muxed_pin *pin, enum mux_setting setting)
-{
-	int ebi_pin, err = 0, can_be_sd = 1;
-	unsigned long ebi_mux;
-
-	ebi_mux = picoxcell_read_register (USE_EBI_GPIO_REG);
-
-	/*
-	 * Find out what EBI pin our GPIO maps to.
-	 */
-	if (pin->arm_pin >= PC3X3_GPIO_PIN_ARM_4 &&
-	    pin->arm_pin < PC3X3_GPIO_PIN_ARM_8) {
-		ebi_pin = 22 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_4);
-	} else if (pin->arm_pin >= PC3X3_GPIO_PIN_ARM_20 &&
-		   pin->arm_pin < PC3X3_GPIO_PIN_ARM_24) {
-		ebi_pin = 18 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_20);
-	} else {
-		/* These aren't shared gpio pins. */
-		ebi_pin = 14 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_14);
-		can_be_sd = 0;
-	}
-
-	if (MUX_SD == setting && !can_be_sd) {
-		err = -EINVAL;
-		goto out;
-	}
-
-	/* Use the pin as EBI. */
-	if (MUX_PERIPHERAL == setting)
-		ebi_mux &= ~(1 << (ebi_pin - 14));
-	else
-		ebi_mux |= (1 << (ebi_pin - 14));
-
-	picoxcell_write_register (ebi_mux, USE_EBI_GPIO_REG);
-
-	/*
-	 * Make sure that the configuration is valid (the GPIO isn't going to
-	 * the PAI).
-	 */
-	if (picoxcell_read_register (USE_EBI_GPIO_REG) != ebi_mux) {
-		err = -EBUSY;
-		goto out;
-	}
-
-	/*
-	 * If we can be SD or ARM and we want to be gpio, pick the correct
-	 * one now.
-	 */
-	if (MUX_PERIPHERAL != setting && can_be_sd)
-		pc3xx_shd_gpio_set_mux (pin->arm_pin, setting);
-
-out:
-	return err;
-}
-
-/*
- * ebi_addr[25:18] pads - these pads can be either the EBI or arm gpio or
- * sdgpio. Note: the gpio pins can also be routed to the pai_tx/rx_data pads.
- *
- * A pad may only be used for GPIO if the corresponding GPIO pin is not
- * already routed to the pai tx/rx data pad. The same applies in the reverse
- * direction. Hardware interlocks exist to prevent this from happening.
- */
-static struct muxed_pin ebi_addr_18_25[] = {
-	PIN (ebi_addr18, PC3X3_GPIO_PIN_SDGPIO_4, PC3X3_GPIO_PIN_ARM_20,
-	     pc3x3_shd_ebi_set_mux, pc3x3_shd_ebi_get_mux),
-	PIN (ebi_addr19, PC3X3_GPIO_PIN_SDGPIO_5, PC3X3_GPIO_PIN_ARM_21,
-	     pc3x3_shd_ebi_set_mux, pc3x3_shd_ebi_get_mux),
-	PIN (ebi_addr20, PC3X3_GPIO_PIN_SDGPIO_6, PC3X3_GPIO_PIN_ARM_22,
-	     pc3x3_shd_ebi_set_mux, pc3x3_shd_ebi_get_mux),
-	PIN (ebi_addr21, PC3X3_GPIO_PIN_SDGPIO_7, PC3X3_GPIO_PIN_ARM_23,
-	     pc3x3_shd_ebi_set_mux, pc3x3_shd_ebi_get_mux),
-	PIN (ebi_addr22, PC3X3_GPIO_PIN_SDGPIO_20, PC3X3_GPIO_PIN_ARM_4,
-	     pc3x3_shd_ebi_set_mux, pc3x3_shd_ebi_get_mux),
-	PIN (ebi_addr23, PC3X3_GPIO_PIN_SDGPIO_21, PC3X3_GPIO_PIN_ARM_5,
-	     pc3x3_shd_ebi_set_mux, pc3x3_shd_ebi_get_mux),
-	PIN (ebi_addr24, PC3X3_GPIO_PIN_SDGPIO_22, PC3X3_GPIO_PIN_ARM_6,
-	     pc3x3_shd_ebi_set_mux, pc3x3_shd_ebi_get_mux),
-	PIN (ebi_addr25, PC3X3_GPIO_PIN_SDGPIO_23, PC3X3_GPIO_PIN_ARM_7,
-	     pc3x3_shd_ebi_set_mux, pc3x3_shd_ebi_get_mux),
-};
+	if (def->periph > 0) {
+		periph_ctrl = axi2cfg_readl(def->periph_reg);
 
-static struct pin_group ebi_addr_18_25_group = {
-	.nr_pins = ARRAY_SIZE (ebi_addr_18_25),
-	.name = "ebi_addr[25:18]",
-	.pins = ebi_addr_18_25,
-};
-
-static int pc3x3_shd_pai_get_mux (struct muxed_pin *pin)
-{
-	int bit, err = 0, can_be_sd = 1;
-	unsigned long pai_mux;
-
-	pai_mux = picoxcell_read_register (USE_PAI_GPIO_REG);
-
-	/*
-	 * Find out what pai pin our GPIO maps to.
-	 */
-	if (pin->arm_pin >= PC3X3_GPIO_PIN_ARM_4 &&
-	    pin->arm_pin < PC3X3_GPIO_PIN_ARM_8) {
-		/* pai_tx_data[3:0] */
-		bit = pin->arm_pin - PC3X3_GPIO_PIN_ARM_4;
-	} else if (pin->arm_pin >= PC3X3_GPIO_PIN_ARM_20 &&
-		   pin->arm_pin < PC3X3_GPIO_PIN_ARM_24) {
-		/* pai_rx_data[3:0] */
-		bit = 8 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_20);
-	} else if (pin->arm_pin >= PC3X3_GPIO_PIN_ARM_24 &&
-		   pin->arm_pin < PC3X3_GPIO_PIN_ARM_28) {
-		/* pai_tx_data[7:4] */
-		bit = 4 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_24);
-		can_be_sd = 0;
-	} else {
-		/* pai_rx_data[7:4] */
-		bit = 12 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_28);
-		can_be_sd = 0;
-	}
-
-	if (!(pai_mux & (1 << bit))) {
-		err = MUX_PERIPHERAL;
-		goto out;
-	}
-
-	if (can_be_sd)
-		err = pc3xx_get_shd_mux (pin);
-	else
-		err = MUX_ARM;
-
-out:
-	return err;
-}
-
-static int
-pc3x3_shd_pai_set_mux (struct muxed_pin *pin, enum mux_setting setting)
-{
-	int bit, err = 0, can_be_sd = 1;
-	unsigned long pai_mux;
-
-	pai_mux = picoxcell_read_register (USE_PAI_GPIO_REG);
-
-	/*
-	 * Find out what pai pin our GPIO maps to.
-	 */
-	if (pin->arm_pin >= PC3X3_GPIO_PIN_ARM_4 &&
-	    pin->arm_pin < PC3X3_GPIO_PIN_ARM_8) {
-		/* pai_tx_data[3:0] */
-		bit = pin->arm_pin - PC3X3_GPIO_PIN_ARM_4;
-	} else if (pin->arm_pin >= PC3X3_GPIO_PIN_ARM_20 &&
-		   pin->arm_pin < PC3X3_GPIO_PIN_ARM_24) {
-		/* pai_rx_data[3:0] */
-		bit = 8 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_20);
-	} else if (pin->arm_pin >= PC3X3_GPIO_PIN_ARM_24 &&
-		   pin->arm_pin < PC3X3_GPIO_PIN_ARM_28) {
-		/* pai_tx_data[7:4] */
-		bit = 4 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_24);
-		can_be_sd = 0;
-	} else {
-		/* pai_rx_data[7:4] */
-		bit = 12 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_28);
-		can_be_sd = 0;
-	}
+		if (setting == def->periph) {
+			/* Enable the peripheral. */
+			if (def->flags & MUX_INVERT_PERIPH)
+				periph_ctrl |= (1 << def->periph_bit);
+			else
+				periph_ctrl &= ~(1 << def->periph_bit);
+		} else {
+			/* Disable the peripheral. */
+			if (def->flags & MUX_INVERT_PERIPH)
+				periph_ctrl &= ~(1 << def->periph_bit);
+			else
+				periph_ctrl |= (1 << def->periph_bit);
+		}
+		axi2cfg_writel(periph_ctrl, def->periph_reg);
 
-	if (MUX_SD == setting && !can_be_sd) {
-		err = -EINVAL;
-		goto out;
+		if (def->periph_b >= 0 && setting == def->periph_b)
+			return 0;
 	}
 
-	/* Use the pin as pai. */
-	if (MUX_PERIPHERAL == setting)
-		pai_mux &= ~(1 << bit);
-	else
-		pai_mux |= (1 << bit);
+	if (setting != def->periph && def->gpio_reg_offs >= 0) {
+		unsigned long gpio_sel = axi2cfg_readl(def->gpio_reg_offs);
 
-	picoxcell_write_register (pai_mux, USE_PAI_GPIO_REG);
+		if (setting == MUX_SD)
+			gpio_sel &= ~(1 << def->gpio_reg_bit);
+		else
+			gpio_sel |= (1 << def->gpio_reg_bit);
 
-	/*
-	 * Make sure that the configuration is valid (the GPIO isn't going to
-	 * the EBI).
-	 */
-	if (picoxcell_read_register (USE_PAI_GPIO_REG) != pai_mux) {
-		err = -EBUSY;
-		goto out;
+		axi2cfg_writel(gpio_sel, def->gpio_reg_offs);
 	}
 
-	/*
-	 * If we can be SD or ARM and we want to be gpio, pick the correct
-	 * one now.
-	 */
-	if (MUX_PERIPHERAL != setting && can_be_sd)
-		pc3xx_shd_gpio_set_mux (pin->arm_pin, setting);
-
-out:
-	return err;
-}
-
-/*
- * pai_rx_data[3:0] pads - these pads can be either the pai_rx_data or arm
- * gpio or sdgpio. Note: the gpio pins can also be routed to the
- * ebi_addr pads.
- *
- * A pad may only be used for GPIO if the corresponding GPIO pin is not
- * already routed to the ebi address pad. The same applies in the reverse
- * direction. Hardware interlocks exist to prevent this from happening.
- */
-static struct muxed_pin pai_rx_data_0_3[] = {
-	PIN (pai_rx_data0, PC3X3_GPIO_PIN_SDGPIO_4, PC3X3_GPIO_PIN_ARM_20,
-	     pc3x3_shd_pai_set_mux, pc3x3_shd_pai_get_mux),
-	PIN (pai_rx_data1, PC3X3_GPIO_PIN_SDGPIO_5, PC3X3_GPIO_PIN_ARM_21,
-	     pc3x3_shd_pai_set_mux, pc3x3_shd_pai_get_mux),
-	PIN (pai_rx_data2, PC3X3_GPIO_PIN_SDGPIO_6, PC3X3_GPIO_PIN_ARM_22,
-	     pc3x3_shd_pai_set_mux, pc3x3_shd_pai_get_mux),
-	PIN (pai_rx_data3, PC3X3_GPIO_PIN_SDGPIO_7, PC3X3_GPIO_PIN_ARM_23,
-	     pc3x3_shd_pai_set_mux, pc3x3_shd_pai_get_mux),
-};
-
-static struct pin_group pai_rx_data_0_3_group = {
-	.nr_pins = ARRAY_SIZE (pai_rx_data_0_3),
-	.name = "pai_rx_data[3:0]",
-	.pins = pai_rx_data_0_3,
-};
-
-/*
- * pai_tx_data[3:0] pads - these pads can be either the pai_tx_data or arm
- * gpio or sdgpio. Note: the gpio pins can also be routed to the
- * ebi_addr pads.
- *
- * A pad may only be used for GPIO if the corresponding GPIO pin is not
- * already routed to the ebi address pad. The same applies in the reverse
- * direction. Hardware interlocks exist to prevent this from happening.
- */
-static struct muxed_pin pai_tx_data_0_3[] = {
-	PIN (pai_tx_data0, PC3X3_GPIO_PIN_SDGPIO_20, PC3X3_GPIO_PIN_ARM_4,
-	     pc3x3_shd_pai_set_mux, pc3x3_shd_pai_get_mux),
-	PIN (pai_tx_data1, PC3X3_GPIO_PIN_SDGPIO_21, PC3X3_GPIO_PIN_ARM_5,
-	     pc3x3_shd_pai_set_mux, pc3x3_shd_pai_get_mux),
-	PIN (pai_tx_data2, PC3X3_GPIO_PIN_SDGPIO_22, PC3X3_GPIO_PIN_ARM_6,
-	     pc3x3_shd_pai_set_mux, pc3x3_shd_pai_get_mux),
-	PIN (pai_tx_data3, PC3X3_GPIO_PIN_SDGPIO_23, PC3X3_GPIO_PIN_ARM_7,
-	     pc3x3_shd_pai_set_mux, pc3x3_shd_pai_get_mux),
-};
-
-static struct pin_group pai_tx_data_0_3_group = {
-	.nr_pins = ARRAY_SIZE (pai_tx_data_0_3),
-	.name = "pai_tx_data[3:0]",
-	.pins = pai_tx_data_0_3,
-};
-
-/*
- * pai_tx_data[7:4] pads - these pads can either be pai_tx_data or arm gpio.
- */
-static struct muxed_pin pai_tx_data_4_7[] = {
-	PIN (pai_tx_data4, -1, PC3X3_GPIO_PIN_ARM_24, pc3x3_shd_pai_set_mux,
-	     pc3x3_shd_pai_get_mux),
-	PIN (pai_tx_data5, -1, PC3X3_GPIO_PIN_ARM_25, pc3x3_shd_pai_set_mux,
-	     pc3x3_shd_pai_get_mux),
-	PIN (pai_tx_data6, -1, PC3X3_GPIO_PIN_ARM_26, pc3x3_shd_pai_set_mux,
-	     pc3x3_shd_pai_get_mux),
-	PIN (pai_tx_data7, -1, PC3X3_GPIO_PIN_ARM_27, pc3x3_shd_pai_set_mux,
-	     pc3x3_shd_pai_get_mux),
-};
-
-static struct pin_group pai_tx_data_4_7_group = {
-	.nr_pins = ARRAY_SIZE (pai_tx_data_4_7),
-	.name = "pai_tx_data[7:4]",
-	.pins = pai_tx_data_4_7,
-};
-
-/*
- * pai_rx_data[7:4] pads - these pads can either be pai_rx_data or arm gpio.
- */
-static struct muxed_pin pai_rx_data_4_7[] = {
-	PIN (pai_rx_data4, -1, PC3X3_GPIO_PIN_ARM_28, pc3x3_shd_pai_set_mux,
-	     pc3x3_shd_pai_get_mux),
-	PIN (pai_rx_data5, -1, PC3X3_GPIO_PIN_ARM_29, pc3x3_shd_pai_set_mux,
-	     pc3x3_shd_pai_get_mux),
-	PIN (pai_rx_data6, -1, PC3X3_GPIO_PIN_ARM_30, pc3x3_shd_pai_set_mux,
-	     pc3x3_shd_pai_get_mux),
-	PIN (pai_rx_data7, -1, PC3X3_GPIO_PIN_ARM_31, pc3x3_shd_pai_set_mux,
-	     pc3x3_shd_pai_get_mux),
-};
-
-static struct pin_group pai_rx_data_4_7_group = {
-	.nr_pins = ARRAY_SIZE (pai_rx_data_4_7),
-	.name = "pai_rx_data[7:4]",
-	.pins = pai_rx_data_4_7,
-};
-
-/*
- * ebi_addr[17:14] pads - these pads can either be ebi_addr or arm gpio.
- */
-static struct muxed_pin ebi_addr_14_17[] = {
-	PIN (ebi_addr14, -1, PC3X3_GPIO_PIN_ARM_32, pc3x3_shd_ebi_set_mux,
-	     pc3x3_shd_ebi_get_mux),
-	PIN (ebi_addr15, -1, PC3X3_GPIO_PIN_ARM_33, pc3x3_shd_ebi_set_mux,
-	     pc3x3_shd_ebi_get_mux),
-	PIN (ebi_addr16, -1, PC3X3_GPIO_PIN_ARM_34, pc3x3_shd_ebi_set_mux,
-	     pc3x3_shd_ebi_get_mux),
-	PIN (ebi_addr17, -1, PC3X3_GPIO_PIN_ARM_35, pc3x3_shd_ebi_set_mux,
-	     pc3x3_shd_ebi_get_mux),
-};
-
-static struct pin_group ebi_addr_14_17_group = {
-	.nr_pins = ARRAY_SIZE (ebi_addr_14_17),
-	.name = "ebi_addr[17:14]",
-	.pins = ebi_addr_14_17,
-};
-
-static int decode_get_mux (struct muxed_pin *pin)
-{
-	unsigned bit = 1 << (pin->arm_pin - PC3X3_GPIO_PIN_ARM_36);
-	unsigned long use_decode_gpio =
-	    picoxcell_read_register (USE_DECODE_GPIO_REG);
-
-	return use_decode_gpio & (1 << bit) ? MUX_ARM : MUX_PERIPHERAL;
-}
-
-static int decode_set_mux (struct muxed_pin *pin, enum mux_setting setting)
-{
-	unsigned long use_decode_gpio;
-	unsigned bit = pin->arm_pin == PC3X3_GPIO_PIN_ARM_36 ? 0 : 1;
-
-	if (MUX_SD == setting)
-		return -EINVAL;
-
-	use_decode_gpio = picoxcell_read_register (USE_DECODE_GPIO_REG);
-	if (MUX_ARM == setting)
-		use_decode_gpio |= (1 << bit);
-	else
-		use_decode_gpio &= ~(1 << bit);
-	picoxcell_write_register (use_decode_gpio, USE_DECODE_GPIO_REG);
-
 	return 0;
 }
 
-/*
- * decode[3:0] pads - these pads can either be decode pins or arm gpio.
- */
-static struct muxed_pin decode_0_3[] = {
-	PIN (decode0, -1, PC3X3_GPIO_PIN_ARM_36, decode_set_mux,
-	     decode_get_mux),
-	PIN (decode1, -1, PC3X3_GPIO_PIN_ARM_37, decode_set_mux,
-	     decode_get_mux),
-	PIN (decode2, -1, PC3X3_GPIO_PIN_ARM_38, decode_set_mux,
-	     decode_get_mux),
-	PIN (decode3, -1, PC3X3_GPIO_PIN_ARM_39, decode_set_mux,
-	     decode_get_mux),
-};
-
-static struct pin_group decode_0_3_group = {
-	.nr_pins = ARRAY_SIZE (decode_0_3),
-	.name = "decode[3:0]",
-	.pins = decode_0_3,
-};
-
-static int ssi_set_mux (struct muxed_pin *pin, enum mux_setting setting);
-
-static int ssi_get_mux (struct muxed_pin *pin);
-
-/*
- * ssi pads - these pads can either be ssi block pins or arm gpio.
- */
-static struct muxed_pin ssi[] = {
-	PIN (ssi_clk, -1, PC3X3_GPIO_PIN_ARM_40, ssi_set_mux, ssi_get_mux),
-	PIN (ssi_data_in, -1, PC3X3_GPIO_PIN_ARM_41, ssi_set_mux, ssi_get_mux),
-	PIN (ssi_data_out, -1, PC3X3_GPIO_PIN_ARM_42, ssi_set_mux, ssi_get_mux),
-};
-
-static int ssi_get_mux (struct muxed_pin *pin)
-{
-	unsigned long use_misc_int_gpio =
-	    picoxcell_read_register (USE_MISC_INT_GPIO_REG);
-
-	return use_misc_int_gpio & (1 << 0) ? MUX_ARM : MUX_PERIPHERAL;
-}
-
-static int ssi_set_mux (struct muxed_pin *pin, enum mux_setting setting)
+int mux_configure_one(const char *name, enum mux_setting setting)
 {
-	unsigned long use_misc_int_gpio;
+	struct mux_def *def = NULL;
 
-	if (MUX_SD == setting)
-		return -EINVAL;
-
-	use_misc_int_gpio = picoxcell_read_register (USE_MISC_INT_GPIO_REG);
-	if (MUX_PERIPHERAL == setting)
-		use_misc_int_gpio &= ~(1 << 0);
-	else
-		use_misc_int_gpio |= (1 << 0);
-	picoxcell_write_register (use_misc_int_gpio, USE_MISC_INT_GPIO_REG);
+	list_for_each_entry(def, &mux_defs, head)
+		if (!strcmp(name, def->name))
+			return mux_configure(def, setting);
 
-	return 0;
+	return -ENXIO;
 }
 
-static struct pin_group ssi_group = {
-	.nr_pins = ARRAY_SIZE (ssi),
-	.name = "ssi",
-	.pins = ssi,
-};
-
-static int mii_get_mux (struct muxed_pin *pin)
+int mux_configure_table(const struct mux_cfg *cfg,
+			unsigned int nr_cfgs)
 {
-	unsigned long syscfg = syscfg_read ();
-
-	return syscfg & (1 << 13) ? MUX_ARM : MUX_PERIPHERAL;
-}
-
-static int mii_set_mux (struct muxed_pin *pin, enum mux_setting setting)
-{
-	/*
-	 * These are automatically configured by hardware if we are in
-	 * reduced MII mode.
-	 */
-	return -EOPNOTSUPP;
-}
-
-/*
- * mii pads - these pads can either be mii pins or arm gpio.
- */
-static struct muxed_pin mii[] = {
-	PIN (mii_tx_data2, -1, PC3X3_GPIO_PIN_ARM_43, mii_set_mux, mii_get_mux),
-	PIN (mii_tx_data3, -1, PC3X3_GPIO_PIN_ARM_44, mii_set_mux, mii_get_mux),
-	PIN (mii_rx_data2, -1, PC3X3_GPIO_PIN_ARM_45, mii_set_mux, mii_get_mux),
-	PIN (mii_rx_data3, -1, PC3X3_GPIO_PIN_ARM_46, mii_set_mux, mii_get_mux),
-	PIN (mii_col, -1, PC3X3_GPIO_PIN_ARM_47, mii_set_mux, mii_get_mux),
-	PIN (mii_crs, -1, PC3X3_GPIO_PIN_ARM_48, mii_set_mux, mii_get_mux),
-	PIN (mii_tx_clk, -1, PC3X3_GPIO_PIN_ARM_49, mii_set_mux, mii_get_mux),
-};
-
-static struct pin_group mii_group = {
-	.nr_pins = ARRAY_SIZE (mii),
-	.name = "mii",
-	.pins = mii,
-};
-
-static int max_set_mux (struct muxed_pin *pin, enum mux_setting setting);
-
-static int max_get_mux (struct muxed_pin *pin);
-
-/*
- * maxim pads - these pads can either be maxim pins or arm gpio.
- */
-static struct muxed_pin max[] = {
-	PIN (max_tx_ctrl, -1, PC3X3_GPIO_PIN_ARM_50, max_set_mux, max_get_mux),
-	PIN (max_ref_clk, -1, PC3X3_GPIO_PIN_ARM_51, max_set_mux, max_get_mux),
-	PIN (max_trig_clk, -1, PC3X3_GPIO_PIN_ARM_52, max_set_mux, max_get_mux),
-};
-
-static int max_get_mux (struct muxed_pin *pin)
-{
-	unsigned long use_misc_int_gpio =
-	    picoxcell_read_register (USE_MISC_INT_GPIO_REG);
-
-	return use_misc_int_gpio & (1 << 1) ? MUX_ARM : MUX_PERIPHERAL;
-}
-
-static int max_set_mux (struct muxed_pin *pin, enum mux_setting setting)
-{
-	unsigned long use_misc_int_gpio;
-
-	if (MUX_SD == setting)
-		return -EINVAL;
-
-	use_misc_int_gpio = picoxcell_read_register (USE_MISC_INT_GPIO_REG);
-	if (MUX_PERIPHERAL == setting)
-		use_misc_int_gpio &= ~(1 << 1);
-	else
-		use_misc_int_gpio |= (1 << 1);
-	picoxcell_write_register (use_misc_int_gpio, USE_MISC_INT_GPIO_REG);
-
-	return 0;
-}
-
-static struct pin_group max_group = {
-	.nr_pins = ARRAY_SIZE (max),
-	.name = "mii",
-	.pins = max,
-};
-
-static int ebi_clk_get_mux (struct muxed_pin *pin)
-{
-	unsigned long ebi_mux = picoxcell_read_register (USE_EBI_GPIO_REG);
-
-	return ebi_mux & (1 << 13) ? MUX_ARM : MUX_PERIPHERAL;
-}
-
-static int ebi_clk_set_mux (struct muxed_pin *pin, enum mux_setting setting)
-{
-	unsigned long ebi_mux;
-
-	if (MUX_SD == setting)
-		return -EINVAL;
-
-	ebi_mux = picoxcell_read_register (USE_EBI_GPIO_REG);
-	if (MUX_PERIPHERAL == setting)
-		ebi_mux &= ~(1 << 13);
-	else
-		ebi_mux |= (1 << 13);
-	picoxcell_write_register (ebi_mux, USE_EBI_GPIO_REG);
-
-	return 0;
-}
-
-/*
- * ebi clock pads - this pad can either be the ebi clock or an arm gpio.
- */
-static struct muxed_pin ebi_clk[] = {
-	PIN (ebi_clk, -1, PC3X3_GPIO_PIN_ARM_53, ebi_clk_set_mux,
-	     ebi_clk_get_mux),
-};
-
-static struct pin_group ebi_clk_group = {
-	.nr_pins = ARRAY_SIZE (ebi_clk),
-	.name = "ebi_clk",
-	.pins = ebi_clk,
-};
-
-static struct muxed_pin pc3x3_fracn_pins[] = {
-	PIN (sdgpio0, PC3X3_GPIO_PIN_SDGPIO_0, -1, pc3xx_shd_mux,
-	     pc3xx_get_shd_mux),
-};
-
-static struct pin_group pc3x3_fracn_group = {
-	.nr_pins = ARRAY_SIZE (pc3x3_fracn_pins),
-	.name = "fracn/sdgpio0",
-	.pins = pc3x3_fracn_pins,
-};
-
-static struct pin_group *pc3x3_groups[] = {
-	&armgpio_0_4_group,
-	&pc3x3_shd_group,
-	&boot_mode_group,
-	&sdram_speed_sel_group,
-	&mii_rev_en_group,
-	&mii_rmii_en_group,
-	&mii_speed_sel_group,
-	&ebi_addr_18_25_group,
-	&pai_tx_data_0_3_group,
-	&pai_rx_data_0_3_group,
-	&pai_tx_data_4_7_group,
-	&pai_rx_data_4_7_group,
-	&ebi_addr_14_17_group,
-	&decode_0_3_group,
-	&ssi_group,
-	&mii_group,
-	&max_group,
-	&ebi_clk_group,
-	&pc3x3_fracn_group,
-};
-#endif /* CONFIG_PICOCHIP_PC3X3 */
-
-/* Public API -------------------------------------------------------------- */
-/*****************************************************************************
- * Generic level pin multiplexing.
- ****************************************************************************/
-
-static struct {
-	unsigned num_groups;
-	struct pin_group **groups;
-} all_groups;
-
-int picoxcell_pin_set_mux (int pin_nr, enum mux_setting setting)
-{
-	unsigned i, j;
+	unsigned int n;
 	int ret = 0;
 
-	/*
-	 * Don't let users try and trick us - they can't change the hardware
-	 * that much!
-	 */
-	if (MUX_UNMUXED == setting)
-		return -EINVAL;
-
-	for (i = 0; i < all_groups.num_groups; ++i) {
-		struct pin_group *group = all_groups.groups[i];
-		for (j = 0; j < group->nr_pins; ++j) {
-			struct muxed_pin *pin = &group->pins[j];
-			/*
-			 * Dedicated GPIO pins aren't shared with a
-			 * peripheral. This is illegal!
-			 */
-			if (pin->is_dedicated_gpio && MUX_PERIPHERAL == setting)
-				return -EINVAL;
-			if (pin_nr == pin->arm_pin || pin_nr == pin->sd_pin) {
-				ret = pin->set_mux (pin, setting);
-				if (!ret)
-					goto out;
-				/*
-				 * If we failed to set the muxing of this pin,
-				 * carry on looping as we have some
-				 * many-to-many pins so we might pick it up
-				 * again on another output.
-				 */
-			}
-		}
+	for (n = 0; n < nr_cfgs; ++n) {
+		ret = mux_configure_one(cfg[n].name, cfg[n].setting);
+		if (ret)
+			break;
 	}
 
-	/*
-	 * If we don't have a multiplexed pin entry for the requested pin then
-	 * we assume that the pin isn't multiplexed so we don't need to do
-	 * anything.
-	 */
-out:
 	return ret;
 }
-
-int picoxcell_group_set_mux (const char *group_name, enum mux_setting setting)
-{
-	unsigned i, j;
-	int err = -ENXIO;
-
-	/*
-	 * Don't let users try and trick us - they can't change the hardware
-	 * that much!
-	 */
-	if (MUX_UNMUXED == setting)
-		return -EINVAL;
-
-	for (i = 0; i < all_groups.num_groups; ++i) {
-		struct pin_group *group = all_groups.groups[i];
-		if (strcmp (group->name, group_name))
-			continue;
-
-		for (j = 0; j < group->nr_pins; ++j) {
-			struct muxed_pin *pin = &group->pins[j];
-			/*
-			 * Dedicated GPIO pins aren't shared with a
-			 * peripheral. This is illegal!
-			 */
-			if (pin->is_dedicated_gpio && MUX_PERIPHERAL == setting)
-				return -EINVAL;
-			err = pin->set_mux (pin, setting);
-			if (err)
-				goto out;
-		}
-
-		break;
-	}
-
-out:
-	return err;
-}
-
-int picoxcell_get_pin_mux (int pin_nr)
-{
-	unsigned i, j;
-	int ret = 0;
-
-	for (i = 0; i < all_groups.num_groups; ++i) {
-		struct pin_group *group = all_groups.groups[i];
-		for (j = 0; j < group->nr_pins; ++j) {
-			struct muxed_pin *pin = &group->pins[j];
-			if (pin_nr == pin->arm_pin || pin_nr == pin->sd_pin) {
-				int tmp = pin->get_mux (pin);
-				if (tmp < 0)
-					return tmp;
-				ret |= tmp;
-			}
-		}
-	}
-
-	/*
-	 * If we don't have a multiplexed pin entry for the requested pin then
-	 * we assume that the pin isn't multiplexed.
-	 */
-	return ret ? ret : MUX_UNMUXED;
-}
-
-void picoxcell_muxing_init (void)
-{
-	if (!is_pc3x3 ()) {
-#ifdef CONFIG_PICOCHIP_PC3X2
-		all_groups.num_groups = ARRAY_SIZE (pc3x2_groups);
-		all_groups.groups = pc3x2_groups;
-#endif /* CONFIG_PICOCHIP_PC3X2 */
-	} else {
-#ifdef CONFIG_PICOCHIP_PC3X3
-		all_groups.num_groups = ARRAY_SIZE (pc3x3_groups);
-		all_groups.groups = pc3x3_groups;
-#endif /* CONFIG_PICOCHIP_PC3X3 */
-	}
-}
diff --git a/arch/arm/cpu/arm926ejs/picoxcell/utilities.c b/arch/arm/cpu/arm926ejs/picoxcell/utilities.c
index 684defe..f50124d 100644
--- a/arch/arm/cpu/arm926ejs/picoxcell/utilities.c
+++ b/arch/arm/cpu/arm926ejs/picoxcell/utilities.c
@@ -18,6 +18,7 @@
 /* Includes ---------------------------------------------------------------- */
 #include <common.h>
 #include <asm/errno.h>
+#include <asm/io.h>
 #include <asm/arch/picoxcell.h>
 #include <asm/arch/axi2cfg.h>
 #include <asm/arch/fuse.h>
@@ -35,26 +36,6 @@
  */
 #define DEVICE_ID_MASK          ( 0xFF )
 
-/* Configuration port write bit positions. */
-#define CAEID_BIT_MASK     ( 1 << 19 )	/*!< Bit 19 - AE ID signal. */
-#define CADDR_BIT_MASK     ( 1 << 18 )	/*!< Bit 18 - AE ADDR signal. */
-#define CREAD_BIT_MASK     ( 1 << 17 )	/*!< Bit 17 - READ data signal. */
-#define CWRITE_BIT_MASK    ( 1 << 16 )	/*!< Bit 16 - WRITE data signal. */
-
-#define RB_FAIL_MASK       ( 1 << 17 )	/*!< Bit 17 - readback failed. */
-#define RB_VALID_MASK      ( 1 << 16 )	/*!< Bit 16 - readback valid. */
-
-#define RETRIES ( 10 )		/*!< The number of retries for an \
-				 *   AXI2Cfg config read. */
-
-/*! Register offset for the config bus write port (from the axi2cfg2 base
- *  address). */
-#define AXI2CFG_REG_CFG_WR ( 0x0100 )
-
-/*! Register offset for the config bus read port (from the axi2cfg2 base
- *  address). */
-#define AXI2CFG_REG_CFG_RD ( 0x0200 )
-
 /* Constants --------------------------------------------------------------- */
 
 /* Types ------------------------------------------------------------------- */
@@ -79,8 +60,7 @@ unsigned int picoxcell_get_device_id (void)
 {
 	unsigned int device_id;
 
-	device_id = picoxcell_read_register (PICOXCELL_AXI2CFG_BASE +
-					     AXI2CFG_DEVICE_ID_REG_OFFSET);
+	device_id = axi2cfg_readl (AXI2CFG_DEVICE_ID_REG_OFFSET);
 	device_id &= DEVICE_ID_MASK;
 
 	return device_id;
@@ -90,8 +70,7 @@ unsigned int picoxcell_get_revision (void)
 {
 	unsigned int revision_code;
 
-	revision_code = picoxcell_read_register (PICOXCELL_AXI2CFG_BASE +
-						 AXI2CFG_REVISION_ID_REG_OFFSET);
+	revision_code = axi2cfg_readl (AXI2CFG_REVISION_ID_REG_OFFSET);
 	revision_code &= SIXTEEN_BIT_MASK;
 
 	return revision_code;
@@ -101,87 +80,15 @@ unsigned int picoxcell_get_rmii_enabled (void)
 {
 	unsigned int rmii_enabled;
 
-	rmii_enabled = picoxcell_read_register (PICOXCELL_AXI2CFG_BASE +
-						AXI2CFG_SYS_CONFIG_REG_OFFSET);
+	rmii_enabled = axi2cfg_readl (AXI2CFG_SYS_CONFIG_REG_OFFSET);
 	rmii_enabled &= AXI2CFG_RMII_EN;
 
 	return ! !rmii_enabled;
 }
 
-int axi2cfg_config_read (u16 caeid, u16 address, u16 * data, u16 count)
-{
-	u32 val;
-	unsigned int write_p = PICOXCELL_AXI2CFG_BASE + AXI2CFG_REG_CFG_WR;
-	unsigned int read_p = PICOXCELL_AXI2CFG_BASE + AXI2CFG_REG_CFG_RD;
-	u16 to_read = count;
-	u16 rc;
-	unsigned i;
-	unsigned retries;
-
-	val = caeid | CAEID_BIT_MASK;
-	picoxcell_write_register (val, write_p);
-
-	while (to_read) {
-		/* Output the address to read from. */
-		val = (address + (count - to_read)) | CADDR_BIT_MASK;
-		picoxcell_write_register (val, write_p);
-
-		/* Dispatch the read requests. */
-		rc = (to_read > 64) ? 64 : to_read;
-		val = CREAD_BIT_MASK | rc;
-		picoxcell_write_register (val, write_p);
-
-		/* Now read the values. */
-		for (i = 0; i < rc; ++i) {
-			retries = RETRIES;
-			while (retries) {
-				val = picoxcell_read_register (read_p);
-				if (val & (RB_VALID_MASK | RB_FAIL_MASK))
-					break;
-				--retries;
-			}
-
-			if (!retries || (val & RB_FAIL_MASK)) {
-				break;
-			} else
-				data[(count - to_read) + i] = val & 0xFFFF;
-		}
-
-		if (val & RB_FAIL_MASK)
-			break;
-
-		to_read -= rc;
-	}
-
-	return !(val & RB_FAIL_MASK) ? count : -EIO;
-}
-
-int axi2cfg_config_write (u16 caeid, u16 address, u16 * data, u16 count)
-{
-	u32 val;
-	unsigned int write_p = PICOXCELL_AXI2CFG_BASE + AXI2CFG_REG_CFG_WR;
-	unsigned i;
-
-	val = caeid | CAEID_BIT_MASK;
-	picoxcell_write_register (val, write_p);
-
-	/* Output the address to write to */
-	val = address | CADDR_BIT_MASK;
-	picoxcell_write_register (val, write_p);
-
-	/* Now write the values. */
-	for (i = 0; i < count; ++i) {
-		val = data[i] | CWRITE_BIT_MASK;
-		picoxcell_write_register (val, write_p);
-	}
-
-	return i;
-}
-
 u32 syscfg_read (void)
 {
-	return picoxcell_read_register (PICOXCELL_AXI2CFG_BASE +
-					AXI2CFG_SYS_CONFIG_REG_OFFSET);
+	return axi2cfg_readl (AXI2CFG_SYS_CONFIG_REG_OFFSET);
 }
 
 void syscfg_update (u32 mask, u32 val)
@@ -189,17 +96,45 @@ void syscfg_update (u32 mask, u32 val)
 	u32 tmp = syscfg_read ();
 	tmp &= ~mask;
 	tmp |= (val & mask);
-	picoxcell_write_register (tmp, (PICOXCELL_AXI2CFG_BASE +
-					AXI2CFG_SYS_CONFIG_REG_OFFSET));
+	axi2cfg_writel (tmp, AXI2CFG_SYS_CONFIG_REG_OFFSET);
 }
 
-__inline int is_pc3x3 (void)
+int picoxcell_is_pc3x2(void)
 {
-	u32 dev_id = picoxcell_read_register (PICOXCELL_AXI2CFG_BASE +
-					      AXI2CFG_DEVICE_ID_REG_OFFSET);
+        unsigned long device_id = axi2cfg_readl (AXI2CFG_DEVICE_ID_REG_OFFSET);
+
+        switch (device_id) {
+        case 0x8003:
+        case 0x8007:
+                return 1;
+        default:
+                return 0;
+        }
+}
 
-	return (dev_id == PC313_DEVICE_ID ||
-		dev_id == PC323_DEVICE_ID || dev_id == PC333_DEVICE_ID);
+int picoxcell_is_pc3x3(void)
+{
+        unsigned long device_id = axi2cfg_readl (AXI2CFG_DEVICE_ID_REG_OFFSET);
+
+        switch (device_id) {
+        case 0x20:
+        case 0x21:
+        case 0x22:
+                return 1;
+        default:
+                return 0;
+        }
+}
+
+int picoxcell_is_pc30xx(void)
+{
+        unsigned long device_id = axi2cfg_readl (AXI2CFG_DEVICE_ID_REG_OFFSET);
+        switch (device_id) {
+        case 0x30 ... 0x3F:
+                return 1;
+        default:
+                return 0;
+        }
 }
 
 void picoxcell_timer_start (int timer)
diff --git a/arch/arm/include/asm/arch-picoxcell/mux.h b/arch/arm/include/asm/arch-picoxcell/mux.h
index d3aeebe..1212cb2 100644
--- a/arch/arm/include/asm/arch-picoxcell/mux.h
+++ b/arch/arm/include/asm/arch-picoxcell/mux.h
@@ -1,47 +1,117 @@
-/*****************************************************************************
- * $picoChipHeaderSubst$
- *****************************************************************************/
-
-/*!
-* \file mux.h
-* \brief Definitions for the picoxcell gpio muxing
-*
-* Copyright (c) 2006-2011 Picochip Ltd
-*
-* This program is free software; you can redistribute it and/or modify
-* it under the terms of the GNU General Public License version 2 as
-* published by the Free Software Foundation.
-*
-* All enquiries to support@picochip.com
-*/
-
-#ifndef __PICOXCELL_MUX_H__
-#define __PICOXCELL_MUX_H__
-
-/* stringify used in mux.c */
-#define __stringify_1(x...)     #x
-#define __stringify(x...)       __stringify_1(x)
-
 /*
- * Pins can typically be:
- *	- a system function such as EBI, SSI etc,
- *	- ARM controlled GPIO.
- *	- picoArray controlled GPIO.
- *	- not multiplexed at all (MUX_UNMUXED).
+ * linux/arch/arm/mach-picoxcell/mux.h
+ *
+ * Copyright (c) 2010 Picochip Ltd., Jamie Iles
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
  */
+#ifndef __MUX_H__
+#define __MUX_H__
+
+#include <linux/list.h>
+
 enum mux_setting {
-	MUX_PERIPHERAL = (1 << 0),
-	MUX_ARM = (1 << 1),
-	MUX_SD = (1 << 2),
-	MUX_UNMUXED = (1 << 3),
+	MUX_PERIPHERAL_RSVD	= -1,
+	MUX_UNMUXED,
+	MUX_ARM,
+	MUX_SD,
+	MUX_PERIPHERAL_FRACN,
+	MUX_PERIPHERAL_EBI,
+	MUX_PERIPHERAL_PAI,
+	MUX_PERIPHERAL_DECODE,
+	MUX_PERIPHERAL_SSI,
+	MUX_PERIPHERAL_MII,
+	MUX_PERIPHERAL_MAXIM,
+	MUX_PERIPHERAL_USIM,
+	NR_MUX_SETTINGS,
+};
+
+enum mux_flags {
+	MUX_RO			= (1 << 0),
+	MUX_INVERT_PERIPH	= (1 << 1),
+	MUX_CONFIG_BUS		= (1 << 2),
+};
+
+struct mux_def {
+	const char		*name;
+	int			armgpio;
+	int			sdgpio;
+	int			periph;
+	int			periph_b;
+	s16			gpio_reg_offs;
+	s16			gpio_reg_bit;
+	s16			periph_reg;
+	s16			periph_bit;
+	u16			caeid;
+	u16			caddr;
+	u16			mask;
+	unsigned		flags;
+	struct list_head	head;
+	enum mux_setting	(*get_setting)(const struct mux_def *def);
+};
+
+struct mux_cfg {
+	const char		*name;
+	enum mux_setting	setting;
 };
 
-int picoxcell_pin_set_mux (int pin_nr, enum mux_setting setting);
+#define MUXCFG(__name, __setting) \
+	{ .name = __name, .setting = __setting }
+
+extern int mux_configure_one(const char *name, enum mux_setting setting);
+extern int mux_configure_table(const struct mux_cfg *cfg,
+			       unsigned int nr_cfgs);
+
+#define MUXGPIO(__name, __arm, __sd, __periph, __gpio_reg, __gpio_bit, \
+		__periph_reg, __periph_bit, __flags) { \
+	.name		= #__name, \
+	.armgpio	= __arm, \
+	.sdgpio		= __sd, \
+	.periph		= MUX_PERIPHERAL_ ## __periph, \
+	.gpio_reg_offs	= __gpio_reg, \
+	.gpio_reg_bit	= __gpio_bit, \
+	.periph_reg	= __periph_reg, \
+	.periph_bit	= __periph_bit, \
+	.periph_b	= -1, \
+	.flags		= __flags, \
+}
+
+#define MUX2PERIPH(__name, __periph, __periph_b, __periph_reg, \
+		   __periph_bit) { \
+	.name		= #__name, \
+	.armgpio	= -1, \
+	.sdgpio		= -1, \
+	.periph		= MUX_PERIPHERAL_ ## __periph, \
+	.periph_b	= MUX_PERIPHERAL_ ## __periph_b, \
+	.periph_reg	= __periph_reg, \
+	.periph_bit	= __periph_bit, \
+}
 
-int picoxcell_group_set_mux (const char *group_name, enum mux_setting setting);
+#define MUXCFGBUS(__name, __arm, __sd, __periph, __caeid, __caddr, __mask) { \
+	.name		= #__name, \
+	.armgpio	= __arm, \
+	.sdgpio		= __sd, \
+	.periph		= MUX_PERIPHERAL_ ## __periph, \
+	.caeid		= __caeid, \
+	.caddr		= __caddr, \
+	.flags		= MUX_CONFIG_BUS, \
+	.mask		= __mask, \
+	.periph_b	= -1, \
+}
 
-int picoxcell_get_pin_mux (int pin_nr);
+#define MUXGPIOFUNC(__name, __arm, __sd, __periph, __get_func) { \
+	.name		= #__name, \
+	.armgpio	= __arm, \
+	.sdgpio		= __sd, \
+	.periph		= MUX_PERIPHERAL_ ## __periph, \
+	.get_setting	= __get_func, \
+	.flags		= MUX_RO, \
+}
 
-void picoxcell_muxing_init (void);
+extern void picoxcell_mux_register(struct mux_def *defs, int nr_defs);
 
-#endif /* __PICOXCELL_MUX_H__ */
+#endif /* __MUX_H__ */
diff --git a/arch/arm/include/asm/arch-picoxcell/utilities.h b/arch/arm/include/asm/arch-picoxcell/utilities.h
index efc68da..599a5bf 100644
--- a/arch/arm/include/asm/arch-picoxcell/utilities.h
+++ b/arch/arm/include/asm/arch-picoxcell/utilities.h
@@ -61,6 +61,22 @@ unsigned int picoxcell_get_revision (void);
 unsigned int picoxcell_get_rmii_enabled (void);
 
 /*!
+ * \brief Read a 32 bit value from an axi2cfg register.
+ *
+ * \param offs The register offset to read from
+ * \return The value read
+ */
+unsigned long axi2cfg_readl(unsigned long offs);
+
+ /*!
+  * \brief Write a 32 bit value to an axi2cfg register
+  *
+  * \param The value to write.
+  * \param The register offset to write to
+  */
+void axi2cfg_writel(unsigned long val, unsigned long offs);
+
+/*!
  * \brief Read a number of 16 bit words from the PC3xx axi2cfg.
  *
  * \param caeid The CAEID of the AE to read from.
@@ -98,12 +114,27 @@ u32 syscfg_read (void);
 void syscfg_update (u32 mask, u32 val);
 
 /*!
+ * \brief Are we running on a PC3x2 ?
+ *
+ * \return 1 if running on a PC3x2 device
+ *         0 if not running on a PC3x2 device
+ */
+int picoxcell_is_pc3x2(void);
+
+/*!
  * \brief Are we running on a PC3x3 ?
  *
  * \return 1 if running on a PC3x3 device
  *         0 if not running on a PC3x3 device
  */
-__inline int is_pc3x3 (void);
+int picoxcell_is_pc3x3(void);
+/*!
+ * \brief Are we running on a PC30xx ?
+ *
+ * \return 1 if running on a PC30xx device
+ *         0 if not running on a PC30xx device
+ */
+int picoxcell_is_pc30xx(void);
 
 /*!
  * Start a timer in free running mode
diff --git a/board/picochip/pc7302/nand.c b/board/picochip/pc7302/nand.c
index 40f3e2a..df27733 100644
--- a/board/picochip/pc7302/nand.c
+++ b/board/picochip/pc7302/nand.c
@@ -63,20 +63,19 @@ static unsigned int rdy;
  * \param ctrl, control data to set up the transaction
  *
  */
-static void nand_cmd_ctrl (struct mtd_info *mtd,
-		           int dat, unsigned int ctrl)
+static void nand_cmd_ctrl (struct mtd_info *mtd, int dat, unsigned int ctrl)
 {
 	struct nand_chip *this = mtd->priv;
 
-        if (ctrl & NAND_CTRL_CHANGE) {
-                picoxcell_gpio_set_value(nce, !(ctrl & NAND_NCE));
-                picoxcell_gpio_set_value(cle, !!(ctrl & NAND_CLE));
-                picoxcell_gpio_set_value(ale, !!(ctrl & NAND_ALE));
-        }
-        if (dat == NAND_CMD_NONE)
-                return;
+	if (ctrl & NAND_CTRL_CHANGE) {
+		picoxcell_gpio_set_value (nce, !(ctrl & NAND_NCE));
+		picoxcell_gpio_set_value (cle, ! !(ctrl & NAND_CLE));
+		picoxcell_gpio_set_value (ale, ! !(ctrl & NAND_ALE));
+	}
+	if (dat == NAND_CMD_NONE)
+		return;
 
-        writeb(dat, this->IO_ADDR_W);
+	writeb (dat, this->IO_ADDR_W);
 }
 
 /*!
@@ -111,29 +110,42 @@ static int nand_dev_ready (struct mtd_info *mtd)
  */
 int board_nand_init (struct nand_chip *nand)
 {
+	int err;
+
+	const struct mux_cfg pc3x2_cfg[] = {
+		MUXCFG ("arm4", MUX_ARM),
+	};
+	const struct mux_cfg pc3x3_cfg[] = {
+		MUXCFG ("pai_tx_data0", MUX_PERIPHERAL_PAI),
+		MUXCFG ("ebi_addr22", MUX_ARM),
+	};
+
 	/* Define which gpio bits are used to control the nand flash
 	 *
-	 * Note: These pin definitions mean that we can only use nand
-	 *       flash if we are running U-Boot from RAM and have NOT booted
-	 *       the Picoxcell device from parallel nor flash.
+	 * Note: These pin definitions mean that we can only use nand flash
+	 *       if we are running U-Boot from RAM and have NOT booted the
+	 *       Picoxcell device from parallel nor flash.
 	 */
-	if (is_pc3x3 ()) {
+	if (picoxcell_is_pc3x3 ()) {
 		cle = PC3X3_GPIO_PIN_ARM_4;
 		ale = PC3X3_GPIO_PIN_ARM_3;
 		nce = PC3X3_GPIO_PIN_ARM_2;
 		rdy = PC3X3_GPIO_PIN_ARM_1;
-
-		/* Setup some pin muxing */
-		picoxcell_group_set_mux ("pai_tx_data[3:0]", MUX_PERIPHERAL);
-		picoxcell_pin_set_mux (PC3X3_GPIO_PIN_ARM_4, MUX_ARM);
 	} else {
 		cle = PC302_GPIO_PIN_ARM_4;
 		ale = PC302_GPIO_PIN_ARM_3;
 		nce = PC302_GPIO_PIN_ARM_2;
 		rdy = PC302_GPIO_PIN_ARM_1;
+	}
 
-		/* Setup some pin muxing */
-		picoxcell_pin_set_mux (PC302_GPIO_PIN_ARM_4, MUX_ARM);
+	/* Setup some pin muxing */
+	if (picoxcell_is_pc3x3 ())
+		err = mux_configure_table (pc3x3_cfg, ARRAY_SIZE (pc3x3_cfg));
+	else
+		err = mux_configure_table (pc3x2_cfg, ARRAY_SIZE (pc3x2_cfg));
+	if (err) {
+		printf ("unable to set ebi_addr22 for use as gpio-nand cle\n");
+		return err;
 	}
 
 	/* Request the required gpio pins */
diff --git a/board/picochip/pc7302/pc7302.c b/board/picochip/pc7302/pc7302.c
index 02b58f3..e0303a1 100644
--- a/board/picochip/pc7302/pc7302.c
+++ b/board/picochip/pc7302/pc7302.c
@@ -22,6 +22,101 @@
 #include <asm/arch/picoxcell_gpio.h>
 
 /* Macros ------------------------------------------------------------------ */
+static struct mux_def pc3x2_mux[] = {
+	/*	Name		ARM	SD	PERIPH	CAEID	CADDR	MASK*/
+	MUXCFGBUS(sdgpio4,	-1,	4,	PAI,	0x8080,	0x9,	0x7),
+	MUXCFGBUS(sdgpio5,	-1,	5,	PAI,	0x8080,	0x9,	0x6),
+	MUXCFGBUS(sdgpio6,	-1,	6,	PAI,	0x8080,	0x9,	0x5),
+	MUXCFGBUS(sdgpio7,	-1,	7,	PAI,	0x8080,	0x9,	0x4),
+
+	MUXCFGBUS(arm4,		4,	-1,	PAI,	0x8080,	0x9,	0xb),
+	MUXCFGBUS(arm5,		5,	-1,	PAI,	0x8080,	0x9,	0xa),
+	MUXCFGBUS(arm6,		6,	-1,	PAI,	0x8080,	0x9,	0x9),
+	MUXCFGBUS(arm7,		7,	-1,	PAI,	0x8080,	0x9,	0x8),
+
+	/*	Name		ARM	SD	PERIPH	REG	BIT	PERREG	PERBIT	FLAGS */
+	MUXGPIO(shared0,	8,	8,	FRACN,	0,	16,	0,	7,	0),
+	MUXGPIO(shared1,	9,	9,	RSVD,	0,	17,	-1,	-1,	0),
+	MUXGPIO(shared2,	10,	10,	RSVD,	0,	18,	-1,	-1,	0),
+	MUXGPIO(shared3,	11,	11,	RSVD,	0,	19,	-1,	-1,	0),
+	MUXGPIO(shared4,	12,	12,	RSVD,	0,	20,	-1,	-1,	0),
+	MUXGPIO(shared5,	13,	13,	RSVD,	0,	21,	-1,	-1,	0),
+	MUXGPIO(shared6,	14,	14,	RSVD,	0,	22,	-1,	-1,	0),
+	MUXGPIO(shared7,	15,	15,	RSVD,	0,	23,	-1,	-1,	0),
+
+	MUXGPIO(sdgpio0,	-1,	0,	FRACN,	-1,	-1,	0,	7,	MUX_INVERT_PERIPH),
+};
+
+static struct mux_def pc3x3_mux[] = {
+	/*	Name		ARM	SD	PERIPH	REG	BIT	PERREG	PERBIT	FLAGS */
+	MUXGPIO(arm_gpio0,	0,	16,	RSVD,	0x34,	0,	-1,	-1,	0),
+	MUXGPIO(arm_gpio1,	1,	17,	RSVD,	0x34,	1,	-1,	-1,	0),
+	MUXGPIO(arm_gpio2,	2,	18,	RSVD,	0x34,	2,	-1,	-1,	0),
+	MUXGPIO(arm_gpio3,	3,	19,	RSVD,	0x34,	3,	-1,	-1,	0),
+	MUXGPIO(shd_gpio,	8,	8,	RSVD,	0x34,	8,	-1,	-1,	0),
+	MUXGPIO(boot_mode0,	9,	9,	RSVD,	0x34,	9,	-1,	-1,	0),
+	MUXGPIO(boot_mode1,	10,	10,	RSVD,	0x34,	10,	-1,	-1,	0),
+	MUXGPIO(sdram_speed_sel,11,	11,	RSVD,	0x34,	11,	-1,	-1,	0),
+	MUXGPIO(mii_rev_en,	12,	12,	RSVD,	0x34,	12,	-1,	-1,	0),
+	MUXGPIO(mii_rmii_en,	13,	13,	RSVD,	0x34,	13,	-1,	-1,	0),
+	MUXGPIO(mii_speed_sel,	14,	14,	RSVD,	0x34,	14,	-1,	-1,	0),
+
+	MUXGPIO(ebi_addr14,	32,	-1,	EBI,	-1,	-1,	0x3c,	0,	0),
+	MUXGPIO(ebi_addr15,	33,	-1,	EBI,	-1,	-1,	0x3c,	1,	0),
+	MUXGPIO(ebi_addr16,	34,	-1,	EBI,	-1,	-1,	0x3c,	2,	0),
+	MUXGPIO(ebi_addr17,	35,	-1,	EBI,	-1,	-1,	0x3c,	3,	0),
+	MUXGPIO(ebi_addr18,	20,	4,	EBI,	0x34,	20,	0x3c,	4,	0),
+	MUXGPIO(ebi_addr19,	21,	5,	EBI,	0x34,	21,	0x3c,	5,	0),
+	MUXGPIO(ebi_addr20,	22,	6,	EBI,	0x34,	22,	0x3c,	6,	0),
+	MUXGPIO(ebi_addr21,	23,	7,	EBI,	0x34,	23,	0x3c,	7,	0),
+	MUXGPIO(ebi_addr22,	4,	20,	EBI,	0x34,	4,	0x3c,	8,	0),
+	MUXGPIO(ebi_addr23,	5,	21,	EBI,	0x34,	5,	0x3c,	9,	0),
+	MUXGPIO(ebi_addr24,	6,	22,	EBI,	0x34,	6,	0x3c,	10,	0),
+	MUXGPIO(ebi_addr25,	7,	23,	EBI,	0x34,	7,	0x3c,	11,	0),
+	MUXGPIO(ebi_addr26,	15,	15,	EBI,	0x34,	15,	0x3c,	12,	0),
+	MUXGPIO(ebi_clk_pin,	53,	-1,	EBI,	-1,	-1,	0x3c,	13,	0),
+
+	MUXGPIO(pai_rx_data0,	20,	4,	PAI,	0x34,	20,	0x38,	8,	0),
+	MUXGPIO(pai_rx_data1,	21,	5,	PAI,	0x34,	21,	0x38,	9,	0),
+	MUXGPIO(pai_rx_data2,	22,	6,	PAI,	0x34,	22,	0x38,	10,	0),
+	MUXGPIO(pai_rx_data3,	23,	7,	PAI,	0x34,	23,	0x38,	11,	0),
+	MUXGPIO(pai_rx_data4,	28,	-1,	PAI,	-1,	-1,	0x38,	4,	0),
+	MUXGPIO(pai_rx_data5,	29,	-1,	PAI,	-1,	-1,	0x38,	5,	0),
+	MUXGPIO(pai_rx_data6,	30,	-1,	PAI,	-1,	-1,	0x38,	6,	0),
+	MUXGPIO(pai_rx_data7,	31,	-1,	PAI,	-1,	-1,	0x38,	7,	0),
+
+	MUXGPIO(pai_tx_data0,	4,	20,	PAI,	0x34,	4,	0x38,	0,	0),
+	MUXGPIO(pai_tx_data1,	5,	21,	PAI,	0x34,	5,	0x38,	1,	0),
+	MUXGPIO(pai_tx_data2,	6,	22,	PAI,	0x34,	6,	0x38,	2,	0),
+	MUXGPIO(pai_tx_data3,	7,	23,	PAI,	0x34,	7,	0x38,	3,	0),
+	MUXGPIO(pai_tx_data4,	24,	-1,	PAI,	-1,	-1,	0x38,	4,	0),
+	MUXGPIO(pai_tx_data5,	25,	-1,	PAI,	-1,	-1,	0x38,	5,	0),
+	MUXGPIO(pai_tx_data6,	26,	-1,	PAI,	-1,	-1,	0x38,	6,	0),
+	MUXGPIO(pai_tx_data7,	27,	-1,	PAI,	-1,	-1,	0x38,	7,	0),
+
+	MUXGPIO(decode0,	36,	-1,	DECODE,	-1,	-1,	0x40,	0,	0),
+	MUXGPIO(decode1,	37,	-1,	DECODE,	-1,	-1,	0x40,	1,	0),
+	MUXGPIO(decode2,	38,	-1,	DECODE,	-1,	-1,	0x40,	2,	0),
+	MUXGPIO(decode3,	39,	-1,	DECODE,	-1,	-1,	0x40,	3,	0),
+
+	MUXGPIO(ssi_clk,	40,	-1,	SSI,	-1,	-1,	0x44,	0,	0),
+	MUXGPIO(ssi_data_in,	41,	-1,	SSI,	-1,	-1,	0x44,	0,	0),
+	MUXGPIO(ssi_data_out,	42,	-1,	SSI,	-1,	-1,	0x44,	0,	0),
+
+	MUXGPIO(mii_tx_data2,	43,	-1,	MII,	-1,	-1,	0,	13,	MUX_RO),
+	MUXGPIO(mii_tx_data3,	44,	-1,	MII,	-1,	-1,	0,	13,	MUX_RO),
+	MUXGPIO(mii_rx_data2,	45,	-1,	MII,	-1,	-1,	0,	13,	MUX_RO),
+	MUXGPIO(mii_rx_data3,	46,	-1,	MII,	-1,	-1,	0,	13,	MUX_RO),
+	MUXGPIO(mii_col,	47,	-1,	MII,	-1,	-1,	0,	13,	MUX_RO),
+	MUXGPIO(mii_crs,	48,	-1,	MII,	-1,	-1,	0,	13,	MUX_RO),
+	MUXGPIO(mii_tx_clk,	49,	-1,	MII,	-1,	-1,	0,	13,	MUX_RO),
+
+	MUXGPIO(max_tx_ctrl,	50,	-1,	MAXIM,	-1,	-1,	0x44,	1,	0),
+	MUXGPIO(max_ref_clk,	51,	-1,	MAXIM,	-1,	-1,	0x44,	1,	0),
+	MUXGPIO(max_trig_clk,	52,	-1,	MAXIM,	-1,	-1,	0x44,	1,	0),
+
+	MUXGPIO(sdgpio0,	-1,	0,	FRACN,	-1,	-1,	0,	7,	MUX_INVERT_PERIPH),
+};
 
 /* Constants --------------------------------------------------------------- */
 DECLARE_GLOBAL_DATA_PTR;
@@ -72,7 +167,11 @@ int board_init (void)
 	picoxcell_timer_start (0);
 
 	/* Initialise the gpio muxing library */
-	picoxcell_muxing_init ();
+	if (picoxcell_is_pc3x2 ()) {
+		picoxcell_mux_register (pc3x2_mux, ARRAY_SIZE (pc3x2_mux));
+	} else {
+		picoxcell_mux_register (pc3x3_mux, ARRAY_SIZE (pc3x3_mux));
+	}
 
 	/* Initialise the gpio library */
 	picoxcell_gpio_init ();
diff --git a/board/picochip/pc7308/pc7308.c b/board/picochip/pc7308/pc7308.c
index bd4b700..c65bf75 100644
--- a/board/picochip/pc7308/pc7308.c
+++ b/board/picochip/pc7308/pc7308.c
@@ -22,6 +22,56 @@
 #include <asm/arch/picoxcell_gpio.h>
 
 /* Macros ------------------------------------------------------------------ */
+static struct mux_def pc30xx_hnb_mux[] = {
+	/*	Name		ARM	SD	PERIPH	REG	BIT	PERREG	PERBIT	FLAGS */
+	MUXGPIO(usim_clk,	0,	16,	USIM,	0x34,	0,	0xc0,	4,	MUX_INVERT_PERIPH),
+	MUXGPIO(usim_io,	1,	17,	USIM,	0x34,	1,	0xc0,	1,	MUX_INVERT_PERIPH),
+	MUXGPIO(usim_vcc,	2,	18,	RSVD,	0x34,	2,	-1,	-1,	0),
+	MUXGPIO(usim_rst,	3,	19,	RSVD,	0x34,	3,	-1,	-1,	0),
+	MUXGPIO(usim_cd,	4,	20,	RSVD,	0x34,	4,	-1,	-1,	0),
+	MUXGPIO(shd_gpio5,	5,	21,	RSVD,	0x34,	5,	-1,	-1,	0),
+	MUXGPIO(shd_gpio6,	6,	22,	RSVD,	0x34,	6,	-1,	-1,	0),
+	MUXGPIO(shd_gpio7,	7,	23,	RSVD,	0x34,	7,	-1,	-1,	0),
+	MUXGPIO(shd_gpio8,	8,	8,	RSVD,	0x34,	8,	-1,	-1,	0),
+	MUXGPIO(shd_gpio9,	9,	9,	RSVD,	0x34,	9,	-1,	-1,	0),
+	MUXGPIO(shd_gpio10,	10,	10,	RSVD,	0x34,	10,	-1,	-1,	0),
+	MUXGPIO(shd_gpio11,	11,	11,	RSVD,	0x34,	11,	-1,	-1,	0),
+	MUXGPIO(shd_gpio12,	12,	12,	RSVD,	0x34,	12,	-1,	-1,	0),
+	MUXGPIO(shd_gpio13,	13,	13,	RSVD,	0x34,	13,	-1,	-1,	0),
+	MUXGPIO(shd_gpio14,	14,	14,	RSVD,	0x34,	14,	-1,	-1,	0),
+	MUXGPIO(shd_gpio15,	15,	15,	FRACN,	0x34,	15,	0,	7,	MUX_INVERT_PERIPH),
+	MUXGPIO(boot_mode0,	16,	0,	RSVD,	0x34,	16,	-1,	-1,	0),
+	MUXGPIO(boot_mode1,	17,	1,	RSVD,	0x34,	17,	-1,	-1,	0),
+	MUXGPIO(input_clk_sel0,	18,	2,	RSVD,	0x34,	18,	-1,	-1,	0),
+	MUXGPIO(input_clk_sel1,	19,	3,	RSVD,	0x34,	19,	-1,	-1,	0),
+	MUXGPIO(ssi_data_out,	22,	6,	SSI,	0x34,	22,	0x44,	0,	0),
+	MUXGPIO(ssi_clk,	23,	7,	SSI,	0x34,	23,	0x44,	0,	0),
+	MUXGPIO(ssi_data_in,	24,	-1,	SSI,	-1,	-1,	0x44,	0,	0),
+	MUXGPIO(decode0,	25,	-1,	EBI,	-1,	-1,	0x40,	0,	0),
+	MUXGPIO(decode1,	26,	-1,	EBI,	-1,	-1,	0x40,	1,	0),
+	MUXGPIO(ebi_clk,	29,	-1,	EBI,	-1,	-1,	0x3c,	13,	0),
+	MUXGPIO(pai_tx_data0,	47,	-1,	PAI,	-1,	-1,	0x38,	0,	0),
+	MUXGPIO(pai_tx_data1,	48,	-1,	PAI,	-1,	-1,	0x38,	1,	0),
+	MUXGPIO(pai_tx_data2,	49,	-1,	PAI,	-1,	-1,	0x38,	2,	0),
+	MUXGPIO(pai_tx_data3,	50,	-1,	PAI,	-1,	-1,	0x38,	3,	0),
+	MUXGPIO(pai_tx_data4,	51,	-1,	PAI,	-1,	-1,	0x38,	4,	0),
+	MUXGPIO(pai_tx_data5,	52,	-1,	PAI,	-1,	-1,	0x38,	5,	0),
+	MUXGPIO(pai_tx_data6,	53,	-1,	PAI,	-1,	-1,	0x38,	6,	0),
+	MUXGPIO(pai_tx_data7,	54,	-1,	PAI,	-1,	-1,	0x38,	7,	0),
+	MUXGPIO(pai_rx_data0,	55,	-1,	PAI,	-1,	-1,	0x38,	8,	0),
+	MUXGPIO(pai_rx_data1,	56,	-1,	PAI,	-1,	-1,	0x38,	9,	0),
+	MUXGPIO(pai_rx_data2,	57,	-1,	PAI,	-1,	-1,	0x38,	10,	0),
+	MUXGPIO(pai_rx_data3,	58,	-1,	PAI,	-1,	-1,	0x38,	11,	0),
+	MUXGPIO(pai_rx_data4,	59,	-1,	PAI,	-1,	-1,	0x38,	12,	0),
+	MUXGPIO(pai_rx_data5,	60,	-1,	PAI,	-1,	-1,	0x38,	13,	0),
+	MUXGPIO(pai_rx_data6,	61,	-1,	PAI,	-1,	-1,	0x38,	14,	0),
+	MUXGPIO(pai_rx_data7,	62,	-1,	PAI,	-1,	-1,	0x38,	15,	0),
+
+	/*	   Name			Periph	PeriphB	Reg	Bit */
+	MUX2PERIPH(pad_pai_tx_clk,	PAI,	MAXIM,	0x4c,	0),
+	MUX2PERIPH(pad_pai_tx_ctrl,	PAI,	MAXIM,	0x4c,	0),
+	MUX2PERIPH(pad_pai_trig_clk,	PAI,	MAXIM,	0x4c,	0),
+};
 
 /* Constants --------------------------------------------------------------- */
 DECLARE_GLOBAL_DATA_PTR;
@@ -72,7 +122,7 @@ int board_init (void)
 	picoxcell_timer_start (0);
 
 	/* Initialise the gpio muxing library */
-	picoxcell_muxing_init ();
+	picoxcell_mux_register (pc30xx_hnb_mux, ARRAY_SIZE (pc30xx_hnb_mux));
 
 	/* Initialise the gpio library */
 	picoxcell_gpio_init ();
-- 
1.7.0.4

